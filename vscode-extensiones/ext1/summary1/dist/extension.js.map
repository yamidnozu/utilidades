{"version":3,"file":"extension.js","mappings":"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","sources":["webpack://edev-summary/./node_modules/braces/index.js","webpack://edev-summary/./node_modules/braces/lib/compile.js","webpack://edev-summary/./node_modules/braces/lib/constants.js","webpack://edev-summary/./node_modules/braces/lib/expand.js","webpack://edev-summary/./node_modules/braces/lib/parse.js","webpack://edev-summary/./node_modules/braces/lib/stringify.js","webpack://edev-summary/./node_modules/braces/lib/utils.js","webpack://edev-summary/./node_modules/fill-range/index.js","webpack://edev-summary/./node_modules/is-number/index.js","webpack://edev-summary/./node_modules/micromatch/index.js","webpack://edev-summary/./node_modules/picomatch/index.js","webpack://edev-summary/./node_modules/picomatch/lib/constants.js","webpack://edev-summary/./node_modules/picomatch/lib/parse.js","webpack://edev-summary/./node_modules/picomatch/lib/picomatch.js","webpack://edev-summary/./node_modules/picomatch/lib/scan.js","webpack://edev-summary/./node_modules/picomatch/lib/utils.js","webpack://edev-summary/./node_modules/to-regex-range/index.js","webpack://edev-summary/./src/SummaryViewProvider.ts","webpack://edev-summary/./src/extension.ts","webpack://edev-summary/external commonjs \"vscode\"","webpack://edev-summary/external node-commonjs \"fs\"","webpack://edev-summary/external node-commonjs \"path\"","webpack://edev-summary/external node-commonjs \"util\"","webpack://edev-summary/webpack/bootstrap","webpack://edev-summary/webpack/startup"],"sourcesContent":["'use strict';\n\nconst stringify = require('./lib/stringify');\nconst compile = require('./lib/compile');\nconst expand = require('./lib/expand');\nconst parse = require('./lib/parse');\n\n/**\n * Expand the given pattern or create a regex-compatible string.\n *\n * ```js\n * const braces = require('braces');\n * console.log(braces('{a,b,c}', { compile: true })); //=> ['(a|b|c)']\n * console.log(braces('{a,b,c}')); //=> ['a', 'b', 'c']\n * ```\n * @param {String} `str`\n * @param {Object} `options`\n * @return {String}\n * @api public\n */\n\nconst braces = (input, options = {}) => {\n  let output = [];\n\n  if (Array.isArray(input)) {\n    for (const pattern of input) {\n      const result = braces.create(pattern, options);\n      if (Array.isArray(result)) {\n        output.push(...result);\n      } else {\n        output.push(result);\n      }\n    }\n  } else {\n    output = [].concat(braces.create(input, options));\n  }\n\n  if (options && options.expand === true && options.nodupes === true) {\n    output = [...new Set(output)];\n  }\n  return output;\n};\n\n/**\n * Parse the given `str` with the given `options`.\n *\n * ```js\n * // braces.parse(pattern, [, options]);\n * const ast = braces.parse('a/{b,c}/d');\n * console.log(ast);\n * ```\n * @param {String} pattern Brace pattern to parse\n * @param {Object} options\n * @return {Object} Returns an AST\n * @api public\n */\n\nbraces.parse = (input, options = {}) => parse(input, options);\n\n/**\n * Creates a braces string from an AST, or an AST node.\n *\n * ```js\n * const braces = require('braces');\n * let ast = braces.parse('foo/{a,b}/bar');\n * console.log(stringify(ast.nodes[2])); //=> '{a,b}'\n * ```\n * @param {String} `input` Brace pattern or AST.\n * @param {Object} `options`\n * @return {Array} Returns an array of expanded values.\n * @api public\n */\n\nbraces.stringify = (input, options = {}) => {\n  if (typeof input === 'string') {\n    return stringify(braces.parse(input, options), options);\n  }\n  return stringify(input, options);\n};\n\n/**\n * Compiles a brace pattern into a regex-compatible, optimized string.\n * This method is called by the main [braces](#braces) function by default.\n *\n * ```js\n * const braces = require('braces');\n * console.log(braces.compile('a/{b,c}/d'));\n * //=> ['a/(b|c)/d']\n * ```\n * @param {String} `input` Brace pattern or AST.\n * @param {Object} `options`\n * @return {Array} Returns an array of expanded values.\n * @api public\n */\n\nbraces.compile = (input, options = {}) => {\n  if (typeof input === 'string') {\n    input = braces.parse(input, options);\n  }\n  return compile(input, options);\n};\n\n/**\n * Expands a brace pattern into an array. This method is called by the\n * main [braces](#braces) function when `options.expand` is true. Before\n * using this method it's recommended that you read the [performance notes](#performance))\n * and advantages of using [.compile](#compile) instead.\n *\n * ```js\n * const braces = require('braces');\n * console.log(braces.expand('a/{b,c}/d'));\n * //=> ['a/b/d', 'a/c/d'];\n * ```\n * @param {String} `pattern` Brace pattern\n * @param {Object} `options`\n * @return {Array} Returns an array of expanded values.\n * @api public\n */\n\nbraces.expand = (input, options = {}) => {\n  if (typeof input === 'string') {\n    input = braces.parse(input, options);\n  }\n\n  let result = expand(input, options);\n\n  // filter out empty strings if specified\n  if (options.noempty === true) {\n    result = result.filter(Boolean);\n  }\n\n  // filter out duplicates if specified\n  if (options.nodupes === true) {\n    result = [...new Set(result)];\n  }\n\n  return result;\n};\n\n/**\n * Processes a brace pattern and returns either an expanded array\n * (if `options.expand` is true), a highly optimized regex-compatible string.\n * This method is called by the main [braces](#braces) function.\n *\n * ```js\n * const braces = require('braces');\n * console.log(braces.create('user-{200..300}/project-{a,b,c}-{1..10}'))\n * //=> 'user-(20[0-9]|2[1-9][0-9]|300)/project-(a|b|c)-([1-9]|10)'\n * ```\n * @param {String} `pattern` Brace pattern\n * @param {Object} `options`\n * @return {Array} Returns an array of expanded values.\n * @api public\n */\n\nbraces.create = (input, options = {}) => {\n  if (input === '' || input.length < 3) {\n    return [input];\n  }\n\n  return options.expand !== true\n    ? braces.compile(input, options)\n    : braces.expand(input, options);\n};\n\n/**\n * Expose \"braces\"\n */\n\nmodule.exports = braces;\n","'use strict';\n\nconst fill = require('fill-range');\nconst utils = require('./utils');\n\nconst compile = (ast, options = {}) => {\n  const walk = (node, parent = {}) => {\n    const invalidBlock = utils.isInvalidBrace(parent);\n    const invalidNode = node.invalid === true && options.escapeInvalid === true;\n    const invalid = invalidBlock === true || invalidNode === true;\n    const prefix = options.escapeInvalid === true ? '\\\\' : '';\n    let output = '';\n\n    if (node.isOpen === true) {\n      return prefix + node.value;\n    }\n\n    if (node.isClose === true) {\n      console.log('node.isClose', prefix, node.value);\n      return prefix + node.value;\n    }\n\n    if (node.type === 'open') {\n      return invalid ? prefix + node.value : '(';\n    }\n\n    if (node.type === 'close') {\n      return invalid ? prefix + node.value : ')';\n    }\n\n    if (node.type === 'comma') {\n      return node.prev.type === 'comma' ? '' : invalid ? node.value : '|';\n    }\n\n    if (node.value) {\n      return node.value;\n    }\n\n    if (node.nodes && node.ranges > 0) {\n      const args = utils.reduce(node.nodes);\n      const range = fill(...args, { ...options, wrap: false, toRegex: true, strictZeros: true });\n\n      if (range.length !== 0) {\n        return args.length > 1 && range.length > 1 ? `(${range})` : range;\n      }\n    }\n\n    if (node.nodes) {\n      for (const child of node.nodes) {\n        output += walk(child, node);\n      }\n    }\n\n    return output;\n  };\n\n  return walk(ast);\n};\n\nmodule.exports = compile;\n","'use strict';\n\nmodule.exports = {\n  MAX_LENGTH: 10000,\n\n  // Digits\n  CHAR_0: '0', /* 0 */\n  CHAR_9: '9', /* 9 */\n\n  // Alphabet chars.\n  CHAR_UPPERCASE_A: 'A', /* A */\n  CHAR_LOWERCASE_A: 'a', /* a */\n  CHAR_UPPERCASE_Z: 'Z', /* Z */\n  CHAR_LOWERCASE_Z: 'z', /* z */\n\n  CHAR_LEFT_PARENTHESES: '(', /* ( */\n  CHAR_RIGHT_PARENTHESES: ')', /* ) */\n\n  CHAR_ASTERISK: '*', /* * */\n\n  // Non-alphabetic chars.\n  CHAR_AMPERSAND: '&', /* & */\n  CHAR_AT: '@', /* @ */\n  CHAR_BACKSLASH: '\\\\', /* \\ */\n  CHAR_BACKTICK: '`', /* ` */\n  CHAR_CARRIAGE_RETURN: '\\r', /* \\r */\n  CHAR_CIRCUMFLEX_ACCENT: '^', /* ^ */\n  CHAR_COLON: ':', /* : */\n  CHAR_COMMA: ',', /* , */\n  CHAR_DOLLAR: '$', /* . */\n  CHAR_DOT: '.', /* . */\n  CHAR_DOUBLE_QUOTE: '\"', /* \" */\n  CHAR_EQUAL: '=', /* = */\n  CHAR_EXCLAMATION_MARK: '!', /* ! */\n  CHAR_FORM_FEED: '\\f', /* \\f */\n  CHAR_FORWARD_SLASH: '/', /* / */\n  CHAR_HASH: '#', /* # */\n  CHAR_HYPHEN_MINUS: '-', /* - */\n  CHAR_LEFT_ANGLE_BRACKET: '<', /* < */\n  CHAR_LEFT_CURLY_BRACE: '{', /* { */\n  CHAR_LEFT_SQUARE_BRACKET: '[', /* [ */\n  CHAR_LINE_FEED: '\\n', /* \\n */\n  CHAR_NO_BREAK_SPACE: '\\u00A0', /* \\u00A0 */\n  CHAR_PERCENT: '%', /* % */\n  CHAR_PLUS: '+', /* + */\n  CHAR_QUESTION_MARK: '?', /* ? */\n  CHAR_RIGHT_ANGLE_BRACKET: '>', /* > */\n  CHAR_RIGHT_CURLY_BRACE: '}', /* } */\n  CHAR_RIGHT_SQUARE_BRACKET: ']', /* ] */\n  CHAR_SEMICOLON: ';', /* ; */\n  CHAR_SINGLE_QUOTE: '\\'', /* ' */\n  CHAR_SPACE: ' ', /*   */\n  CHAR_TAB: '\\t', /* \\t */\n  CHAR_UNDERSCORE: '_', /* _ */\n  CHAR_VERTICAL_LINE: '|', /* | */\n  CHAR_ZERO_WIDTH_NOBREAK_SPACE: '\\uFEFF' /* \\uFEFF */\n};\n","'use strict';\n\nconst fill = require('fill-range');\nconst stringify = require('./stringify');\nconst utils = require('./utils');\n\nconst append = (queue = '', stash = '', enclose = false) => {\n  const result = [];\n\n  queue = [].concat(queue);\n  stash = [].concat(stash);\n\n  if (!stash.length) return queue;\n  if (!queue.length) {\n    return enclose ? utils.flatten(stash).map(ele => `{${ele}}`) : stash;\n  }\n\n  for (const item of queue) {\n    if (Array.isArray(item)) {\n      for (const value of item) {\n        result.push(append(value, stash, enclose));\n      }\n    } else {\n      for (let ele of stash) {\n        if (enclose === true && typeof ele === 'string') ele = `{${ele}}`;\n        result.push(Array.isArray(ele) ? append(item, ele, enclose) : item + ele);\n      }\n    }\n  }\n  return utils.flatten(result);\n};\n\nconst expand = (ast, options = {}) => {\n  const rangeLimit = options.rangeLimit === undefined ? 1000 : options.rangeLimit;\n\n  const walk = (node, parent = {}) => {\n    node.queue = [];\n\n    let p = parent;\n    let q = parent.queue;\n\n    while (p.type !== 'brace' && p.type !== 'root' && p.parent) {\n      p = p.parent;\n      q = p.queue;\n    }\n\n    if (node.invalid || node.dollar) {\n      q.push(append(q.pop(), stringify(node, options)));\n      return;\n    }\n\n    if (node.type === 'brace' && node.invalid !== true && node.nodes.length === 2) {\n      q.push(append(q.pop(), ['{}']));\n      return;\n    }\n\n    if (node.nodes && node.ranges > 0) {\n      const args = utils.reduce(node.nodes);\n\n      if (utils.exceedsLimit(...args, options.step, rangeLimit)) {\n        throw new RangeError('expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.');\n      }\n\n      let range = fill(...args, options);\n      if (range.length === 0) {\n        range = stringify(node, options);\n      }\n\n      q.push(append(q.pop(), range));\n      node.nodes = [];\n      return;\n    }\n\n    const enclose = utils.encloseBrace(node);\n    let queue = node.queue;\n    let block = node;\n\n    while (block.type !== 'brace' && block.type !== 'root' && block.parent) {\n      block = block.parent;\n      queue = block.queue;\n    }\n\n    for (let i = 0; i < node.nodes.length; i++) {\n      const child = node.nodes[i];\n\n      if (child.type === 'comma' && node.type === 'brace') {\n        if (i === 1) queue.push('');\n        queue.push('');\n        continue;\n      }\n\n      if (child.type === 'close') {\n        q.push(append(q.pop(), queue, enclose));\n        continue;\n      }\n\n      if (child.value && child.type !== 'open') {\n        queue.push(append(queue.pop(), child.value));\n        continue;\n      }\n\n      if (child.nodes) {\n        walk(child, node);\n      }\n    }\n\n    return queue;\n  };\n\n  return utils.flatten(walk(ast));\n};\n\nmodule.exports = expand;\n","'use strict';\n\nconst stringify = require('./stringify');\n\n/**\n * Constants\n */\n\nconst {\n  MAX_LENGTH,\n  CHAR_BACKSLASH, /* \\ */\n  CHAR_BACKTICK, /* ` */\n  CHAR_COMMA, /* , */\n  CHAR_DOT, /* . */\n  CHAR_LEFT_PARENTHESES, /* ( */\n  CHAR_RIGHT_PARENTHESES, /* ) */\n  CHAR_LEFT_CURLY_BRACE, /* { */\n  CHAR_RIGHT_CURLY_BRACE, /* } */\n  CHAR_LEFT_SQUARE_BRACKET, /* [ */\n  CHAR_RIGHT_SQUARE_BRACKET, /* ] */\n  CHAR_DOUBLE_QUOTE, /* \" */\n  CHAR_SINGLE_QUOTE, /* ' */\n  CHAR_NO_BREAK_SPACE,\n  CHAR_ZERO_WIDTH_NOBREAK_SPACE\n} = require('./constants');\n\n/**\n * parse\n */\n\nconst parse = (input, options = {}) => {\n  if (typeof input !== 'string') {\n    throw new TypeError('Expected a string');\n  }\n\n  const opts = options || {};\n  const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;\n  if (input.length > max) {\n    throw new SyntaxError(`Input length (${input.length}), exceeds max characters (${max})`);\n  }\n\n  const ast = { type: 'root', input, nodes: [] };\n  const stack = [ast];\n  let block = ast;\n  let prev = ast;\n  let brackets = 0;\n  const length = input.length;\n  let index = 0;\n  let depth = 0;\n  let value;\n\n  /**\n   * Helpers\n   */\n\n  const advance = () => input[index++];\n  const push = node => {\n    if (node.type === 'text' && prev.type === 'dot') {\n      prev.type = 'text';\n    }\n\n    if (prev && prev.type === 'text' && node.type === 'text') {\n      prev.value += node.value;\n      return;\n    }\n\n    block.nodes.push(node);\n    node.parent = block;\n    node.prev = prev;\n    prev = node;\n    return node;\n  };\n\n  push({ type: 'bos' });\n\n  while (index < length) {\n    block = stack[stack.length - 1];\n    value = advance();\n\n    /**\n     * Invalid chars\n     */\n\n    if (value === CHAR_ZERO_WIDTH_NOBREAK_SPACE || value === CHAR_NO_BREAK_SPACE) {\n      continue;\n    }\n\n    /**\n     * Escaped chars\n     */\n\n    if (value === CHAR_BACKSLASH) {\n      push({ type: 'text', value: (options.keepEscaping ? value : '') + advance() });\n      continue;\n    }\n\n    /**\n     * Right square bracket (literal): ']'\n     */\n\n    if (value === CHAR_RIGHT_SQUARE_BRACKET) {\n      push({ type: 'text', value: '\\\\' + value });\n      continue;\n    }\n\n    /**\n     * Left square bracket: '['\n     */\n\n    if (value === CHAR_LEFT_SQUARE_BRACKET) {\n      brackets++;\n\n      let next;\n\n      while (index < length && (next = advance())) {\n        value += next;\n\n        if (next === CHAR_LEFT_SQUARE_BRACKET) {\n          brackets++;\n          continue;\n        }\n\n        if (next === CHAR_BACKSLASH) {\n          value += advance();\n          continue;\n        }\n\n        if (next === CHAR_RIGHT_SQUARE_BRACKET) {\n          brackets--;\n\n          if (brackets === 0) {\n            break;\n          }\n        }\n      }\n\n      push({ type: 'text', value });\n      continue;\n    }\n\n    /**\n     * Parentheses\n     */\n\n    if (value === CHAR_LEFT_PARENTHESES) {\n      block = push({ type: 'paren', nodes: [] });\n      stack.push(block);\n      push({ type: 'text', value });\n      continue;\n    }\n\n    if (value === CHAR_RIGHT_PARENTHESES) {\n      if (block.type !== 'paren') {\n        push({ type: 'text', value });\n        continue;\n      }\n      block = stack.pop();\n      push({ type: 'text', value });\n      block = stack[stack.length - 1];\n      continue;\n    }\n\n    /**\n     * Quotes: '|\"|`\n     */\n\n    if (value === CHAR_DOUBLE_QUOTE || value === CHAR_SINGLE_QUOTE || value === CHAR_BACKTICK) {\n      const open = value;\n      let next;\n\n      if (options.keepQuotes !== true) {\n        value = '';\n      }\n\n      while (index < length && (next = advance())) {\n        if (next === CHAR_BACKSLASH) {\n          value += next + advance();\n          continue;\n        }\n\n        if (next === open) {\n          if (options.keepQuotes === true) value += next;\n          break;\n        }\n\n        value += next;\n      }\n\n      push({ type: 'text', value });\n      continue;\n    }\n\n    /**\n     * Left curly brace: '{'\n     */\n\n    if (value === CHAR_LEFT_CURLY_BRACE) {\n      depth++;\n\n      const dollar = prev.value && prev.value.slice(-1) === '$' || block.dollar === true;\n      const brace = {\n        type: 'brace',\n        open: true,\n        close: false,\n        dollar,\n        depth,\n        commas: 0,\n        ranges: 0,\n        nodes: []\n      };\n\n      block = push(brace);\n      stack.push(block);\n      push({ type: 'open', value });\n      continue;\n    }\n\n    /**\n     * Right curly brace: '}'\n     */\n\n    if (value === CHAR_RIGHT_CURLY_BRACE) {\n      if (block.type !== 'brace') {\n        push({ type: 'text', value });\n        continue;\n      }\n\n      const type = 'close';\n      block = stack.pop();\n      block.close = true;\n\n      push({ type, value });\n      depth--;\n\n      block = stack[stack.length - 1];\n      continue;\n    }\n\n    /**\n     * Comma: ','\n     */\n\n    if (value === CHAR_COMMA && depth > 0) {\n      if (block.ranges > 0) {\n        block.ranges = 0;\n        const open = block.nodes.shift();\n        block.nodes = [open, { type: 'text', value: stringify(block) }];\n      }\n\n      push({ type: 'comma', value });\n      block.commas++;\n      continue;\n    }\n\n    /**\n     * Dot: '.'\n     */\n\n    if (value === CHAR_DOT && depth > 0 && block.commas === 0) {\n      const siblings = block.nodes;\n\n      if (depth === 0 || siblings.length === 0) {\n        push({ type: 'text', value });\n        continue;\n      }\n\n      if (prev.type === 'dot') {\n        block.range = [];\n        prev.value += value;\n        prev.type = 'range';\n\n        if (block.nodes.length !== 3 && block.nodes.length !== 5) {\n          block.invalid = true;\n          block.ranges = 0;\n          prev.type = 'text';\n          continue;\n        }\n\n        block.ranges++;\n        block.args = [];\n        continue;\n      }\n\n      if (prev.type === 'range') {\n        siblings.pop();\n\n        const before = siblings[siblings.length - 1];\n        before.value += prev.value + value;\n        prev = before;\n        block.ranges--;\n        continue;\n      }\n\n      push({ type: 'dot', value });\n      continue;\n    }\n\n    /**\n     * Text\n     */\n\n    push({ type: 'text', value });\n  }\n\n  // Mark imbalanced braces and brackets as invalid\n  do {\n    block = stack.pop();\n\n    if (block.type !== 'root') {\n      block.nodes.forEach(node => {\n        if (!node.nodes) {\n          if (node.type === 'open') node.isOpen = true;\n          if (node.type === 'close') node.isClose = true;\n          if (!node.nodes) node.type = 'text';\n          node.invalid = true;\n        }\n      });\n\n      // get the location of the block on parent.nodes (block's siblings)\n      const parent = stack[stack.length - 1];\n      const index = parent.nodes.indexOf(block);\n      // replace the (invalid) block with it's nodes\n      parent.nodes.splice(index, 1, ...block.nodes);\n    }\n  } while (stack.length > 0);\n\n  push({ type: 'eos' });\n  return ast;\n};\n\nmodule.exports = parse;\n","'use strict';\n\nconst utils = require('./utils');\n\nmodule.exports = (ast, options = {}) => {\n  const stringify = (node, parent = {}) => {\n    const invalidBlock = options.escapeInvalid && utils.isInvalidBrace(parent);\n    const invalidNode = node.invalid === true && options.escapeInvalid === true;\n    let output = '';\n\n    if (node.value) {\n      if ((invalidBlock || invalidNode) && utils.isOpenOrClose(node)) {\n        return '\\\\' + node.value;\n      }\n      return node.value;\n    }\n\n    if (node.value) {\n      return node.value;\n    }\n\n    if (node.nodes) {\n      for (const child of node.nodes) {\n        output += stringify(child);\n      }\n    }\n    return output;\n  };\n\n  return stringify(ast);\n};\n\n","'use strict';\n\nexports.isInteger = num => {\n  if (typeof num === 'number') {\n    return Number.isInteger(num);\n  }\n  if (typeof num === 'string' && num.trim() !== '') {\n    return Number.isInteger(Number(num));\n  }\n  return false;\n};\n\n/**\n * Find a node of the given type\n */\n\nexports.find = (node, type) => node.nodes.find(node => node.type === type);\n\n/**\n * Find a node of the given type\n */\n\nexports.exceedsLimit = (min, max, step = 1, limit) => {\n  if (limit === false) return false;\n  if (!exports.isInteger(min) || !exports.isInteger(max)) return false;\n  return ((Number(max) - Number(min)) / Number(step)) >= limit;\n};\n\n/**\n * Escape the given node with '\\\\' before node.value\n */\n\nexports.escapeNode = (block, n = 0, type) => {\n  const node = block.nodes[n];\n  if (!node) return;\n\n  if ((type && node.type === type) || node.type === 'open' || node.type === 'close') {\n    if (node.escaped !== true) {\n      node.value = '\\\\' + node.value;\n      node.escaped = true;\n    }\n  }\n};\n\n/**\n * Returns true if the given brace node should be enclosed in literal braces\n */\n\nexports.encloseBrace = node => {\n  if (node.type !== 'brace') return false;\n  if ((node.commas >> 0 + node.ranges >> 0) === 0) {\n    node.invalid = true;\n    return true;\n  }\n  return false;\n};\n\n/**\n * Returns true if a brace node is invalid.\n */\n\nexports.isInvalidBrace = block => {\n  if (block.type !== 'brace') return false;\n  if (block.invalid === true || block.dollar) return true;\n  if ((block.commas >> 0 + block.ranges >> 0) === 0) {\n    block.invalid = true;\n    return true;\n  }\n  if (block.open !== true || block.close !== true) {\n    block.invalid = true;\n    return true;\n  }\n  return false;\n};\n\n/**\n * Returns true if a node is an open or close node\n */\n\nexports.isOpenOrClose = node => {\n  if (node.type === 'open' || node.type === 'close') {\n    return true;\n  }\n  return node.open === true || node.close === true;\n};\n\n/**\n * Reduce an array of text nodes.\n */\n\nexports.reduce = nodes => nodes.reduce((acc, node) => {\n  if (node.type === 'text') acc.push(node.value);\n  if (node.type === 'range') node.type = 'text';\n  return acc;\n}, []);\n\n/**\n * Flatten an array\n */\n\nexports.flatten = (...args) => {\n  const result = [];\n\n  const flat = arr => {\n    for (let i = 0; i < arr.length; i++) {\n      const ele = arr[i];\n\n      if (Array.isArray(ele)) {\n        flat(ele);\n        continue;\n      }\n\n      if (ele !== undefined) {\n        result.push(ele);\n      }\n    }\n    return result;\n  };\n\n  flat(args);\n  return result;\n};\n","/*!\n * fill-range <https://github.com/jonschlinkert/fill-range>\n *\n * Copyright (c) 2014-present, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n\n'use strict';\n\nconst util = require('util');\nconst toRegexRange = require('to-regex-range');\n\nconst isObject = val => val !== null && typeof val === 'object' && !Array.isArray(val);\n\nconst transform = toNumber => {\n  return value => toNumber === true ? Number(value) : String(value);\n};\n\nconst isValidValue = value => {\n  return typeof value === 'number' || (typeof value === 'string' && value !== '');\n};\n\nconst isNumber = num => Number.isInteger(+num);\n\nconst zeros = input => {\n  let value = `${input}`;\n  let index = -1;\n  if (value[0] === '-') value = value.slice(1);\n  if (value === '0') return false;\n  while (value[++index] === '0');\n  return index > 0;\n};\n\nconst stringify = (start, end, options) => {\n  if (typeof start === 'string' || typeof end === 'string') {\n    return true;\n  }\n  return options.stringify === true;\n};\n\nconst pad = (input, maxLength, toNumber) => {\n  if (maxLength > 0) {\n    let dash = input[0] === '-' ? '-' : '';\n    if (dash) input = input.slice(1);\n    input = (dash + input.padStart(dash ? maxLength - 1 : maxLength, '0'));\n  }\n  if (toNumber === false) {\n    return String(input);\n  }\n  return input;\n};\n\nconst toMaxLen = (input, maxLength) => {\n  let negative = input[0] === '-' ? '-' : '';\n  if (negative) {\n    input = input.slice(1);\n    maxLength--;\n  }\n  while (input.length < maxLength) input = '0' + input;\n  return negative ? ('-' + input) : input;\n};\n\nconst toSequence = (parts, options, maxLen) => {\n  parts.negatives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);\n  parts.positives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);\n\n  let prefix = options.capture ? '' : '?:';\n  let positives = '';\n  let negatives = '';\n  let result;\n\n  if (parts.positives.length) {\n    positives = parts.positives.map(v => toMaxLen(String(v), maxLen)).join('|');\n  }\n\n  if (parts.negatives.length) {\n    negatives = `-(${prefix}${parts.negatives.map(v => toMaxLen(String(v), maxLen)).join('|')})`;\n  }\n\n  if (positives && negatives) {\n    result = `${positives}|${negatives}`;\n  } else {\n    result = positives || negatives;\n  }\n\n  if (options.wrap) {\n    return `(${prefix}${result})`;\n  }\n\n  return result;\n};\n\nconst toRange = (a, b, isNumbers, options) => {\n  if (isNumbers) {\n    return toRegexRange(a, b, { wrap: false, ...options });\n  }\n\n  let start = String.fromCharCode(a);\n  if (a === b) return start;\n\n  let stop = String.fromCharCode(b);\n  return `[${start}-${stop}]`;\n};\n\nconst toRegex = (start, end, options) => {\n  if (Array.isArray(start)) {\n    let wrap = options.wrap === true;\n    let prefix = options.capture ? '' : '?:';\n    return wrap ? `(${prefix}${start.join('|')})` : start.join('|');\n  }\n  return toRegexRange(start, end, options);\n};\n\nconst rangeError = (...args) => {\n  return new RangeError('Invalid range arguments: ' + util.inspect(...args));\n};\n\nconst invalidRange = (start, end, options) => {\n  if (options.strictRanges === true) throw rangeError([start, end]);\n  return [];\n};\n\nconst invalidStep = (step, options) => {\n  if (options.strictRanges === true) {\n    throw new TypeError(`Expected step \"${step}\" to be a number`);\n  }\n  return [];\n};\n\nconst fillNumbers = (start, end, step = 1, options = {}) => {\n  let a = Number(start);\n  let b = Number(end);\n\n  if (!Number.isInteger(a) || !Number.isInteger(b)) {\n    if (options.strictRanges === true) throw rangeError([start, end]);\n    return [];\n  }\n\n  // fix negative zero\n  if (a === 0) a = 0;\n  if (b === 0) b = 0;\n\n  let descending = a > b;\n  let startString = String(start);\n  let endString = String(end);\n  let stepString = String(step);\n  step = Math.max(Math.abs(step), 1);\n\n  let padded = zeros(startString) || zeros(endString) || zeros(stepString);\n  let maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0;\n  let toNumber = padded === false && stringify(start, end, options) === false;\n  let format = options.transform || transform(toNumber);\n\n  if (options.toRegex && step === 1) {\n    return toRange(toMaxLen(start, maxLen), toMaxLen(end, maxLen), true, options);\n  }\n\n  let parts = { negatives: [], positives: [] };\n  let push = num => parts[num < 0 ? 'negatives' : 'positives'].push(Math.abs(num));\n  let range = [];\n  let index = 0;\n\n  while (descending ? a >= b : a <= b) {\n    if (options.toRegex === true && step > 1) {\n      push(a);\n    } else {\n      range.push(pad(format(a, index), maxLen, toNumber));\n    }\n    a = descending ? a - step : a + step;\n    index++;\n  }\n\n  if (options.toRegex === true) {\n    return step > 1\n      ? toSequence(parts, options, maxLen)\n      : toRegex(range, null, { wrap: false, ...options });\n  }\n\n  return range;\n};\n\nconst fillLetters = (start, end, step = 1, options = {}) => {\n  if ((!isNumber(start) && start.length > 1) || (!isNumber(end) && end.length > 1)) {\n    return invalidRange(start, end, options);\n  }\n\n  let format = options.transform || (val => String.fromCharCode(val));\n  let a = `${start}`.charCodeAt(0);\n  let b = `${end}`.charCodeAt(0);\n\n  let descending = a > b;\n  let min = Math.min(a, b);\n  let max = Math.max(a, b);\n\n  if (options.toRegex && step === 1) {\n    return toRange(min, max, false, options);\n  }\n\n  let range = [];\n  let index = 0;\n\n  while (descending ? a >= b : a <= b) {\n    range.push(format(a, index));\n    a = descending ? a - step : a + step;\n    index++;\n  }\n\n  if (options.toRegex === true) {\n    return toRegex(range, null, { wrap: false, options });\n  }\n\n  return range;\n};\n\nconst fill = (start, end, step, options = {}) => {\n  if (end == null && isValidValue(start)) {\n    return [start];\n  }\n\n  if (!isValidValue(start) || !isValidValue(end)) {\n    return invalidRange(start, end, options);\n  }\n\n  if (typeof step === 'function') {\n    return fill(start, end, 1, { transform: step });\n  }\n\n  if (isObject(step)) {\n    return fill(start, end, 0, step);\n  }\n\n  let opts = { ...options };\n  if (opts.capture === true) opts.wrap = true;\n  step = step || opts.step || 1;\n\n  if (!isNumber(step)) {\n    if (step != null && !isObject(step)) return invalidStep(step, opts);\n    return fill(start, end, 1, step);\n  }\n\n  if (isNumber(start) && isNumber(end)) {\n    return fillNumbers(start, end, step, opts);\n  }\n\n  return fillLetters(start, end, Math.max(Math.abs(step), 1), opts);\n};\n\nmodule.exports = fill;\n","/*!\n * is-number <https://github.com/jonschlinkert/is-number>\n *\n * Copyright (c) 2014-present, Jon Schlinkert.\n * Released under the MIT License.\n */\n\n'use strict';\n\nmodule.exports = function(num) {\n  if (typeof num === 'number') {\n    return num - num === 0;\n  }\n  if (typeof num === 'string' && num.trim() !== '') {\n    return Number.isFinite ? Number.isFinite(+num) : isFinite(+num);\n  }\n  return false;\n};\n","'use strict';\n\nconst util = require('util');\nconst braces = require('braces');\nconst picomatch = require('picomatch');\nconst utils = require('picomatch/lib/utils');\nconst isEmptyString = val => val === '' || val === './';\n\n/**\n * Returns an array of strings that match one or more glob patterns.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm(list, patterns[, options]);\n *\n * console.log(mm(['a.js', 'a.txt'], ['*.js']));\n * //=> [ 'a.js' ]\n * ```\n * @param {String|Array<string>} `list` List of strings to match.\n * @param {String|Array<string>} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options)\n * @return {Array} Returns an array of matches\n * @summary false\n * @api public\n */\n\nconst micromatch = (list, patterns, options) => {\n  patterns = [].concat(patterns);\n  list = [].concat(list);\n\n  let omit = new Set();\n  let keep = new Set();\n  let items = new Set();\n  let negatives = 0;\n\n  let onResult = state => {\n    items.add(state.output);\n    if (options && options.onResult) {\n      options.onResult(state);\n    }\n  };\n\n  for (let i = 0; i < patterns.length; i++) {\n    let isMatch = picomatch(String(patterns[i]), { ...options, onResult }, true);\n    let negated = isMatch.state.negated || isMatch.state.negatedExtglob;\n    if (negated) negatives++;\n\n    for (let item of list) {\n      let matched = isMatch(item, true);\n\n      let match = negated ? !matched.isMatch : matched.isMatch;\n      if (!match) continue;\n\n      if (negated) {\n        omit.add(matched.output);\n      } else {\n        omit.delete(matched.output);\n        keep.add(matched.output);\n      }\n    }\n  }\n\n  let result = negatives === patterns.length ? [...items] : [...keep];\n  let matches = result.filter(item => !omit.has(item));\n\n  if (options && matches.length === 0) {\n    if (options.failglob === true) {\n      throw new Error(`No matches found for \"${patterns.join(', ')}\"`);\n    }\n\n    if (options.nonull === true || options.nullglob === true) {\n      return options.unescape ? patterns.map(p => p.replace(/\\\\/g, '')) : patterns;\n    }\n  }\n\n  return matches;\n};\n\n/**\n * Backwards compatibility\n */\n\nmicromatch.match = micromatch;\n\n/**\n * Returns a matcher function from the given glob `pattern` and `options`.\n * The returned function takes a string to match as its only argument and returns\n * true if the string is a match.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.matcher(pattern[, options]);\n *\n * const isMatch = mm.matcher('*.!(*a)');\n * console.log(isMatch('a.a')); //=> false\n * console.log(isMatch('a.b')); //=> true\n * ```\n * @param {String} `pattern` Glob pattern\n * @param {Object} `options`\n * @return {Function} Returns a matcher function.\n * @api public\n */\n\nmicromatch.matcher = (pattern, options) => picomatch(pattern, options);\n\n/**\n * Returns true if **any** of the given glob `patterns` match the specified `string`.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.isMatch(string, patterns[, options]);\n *\n * console.log(mm.isMatch('a.a', ['b.*', '*.a'])); //=> true\n * console.log(mm.isMatch('a.a', 'b.*')); //=> false\n * ```\n * @param {String} `str` The string to test.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `[options]` See available [options](#options).\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\n\nmicromatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);\n\n/**\n * Backwards compatibility\n */\n\nmicromatch.any = micromatch.isMatch;\n\n/**\n * Returns a list of strings that _**do not match any**_ of the given `patterns`.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.not(list, patterns[, options]);\n *\n * console.log(mm.not(['a.a', 'b.b', 'c.c'], '*.a'));\n * //=> ['b.b', 'c.c']\n * ```\n * @param {Array} `list` Array of strings to match.\n * @param {String|Array} `patterns` One or more glob pattern to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Array} Returns an array of strings that **do not match** the given patterns.\n * @api public\n */\n\nmicromatch.not = (list, patterns, options = {}) => {\n  patterns = [].concat(patterns).map(String);\n  let result = new Set();\n  let items = [];\n\n  let onResult = state => {\n    if (options.onResult) options.onResult(state);\n    items.push(state.output);\n  };\n\n  let matches = new Set(micromatch(list, patterns, { ...options, onResult }));\n\n  for (let item of items) {\n    if (!matches.has(item)) {\n      result.add(item);\n    }\n  }\n  return [...result];\n};\n\n/**\n * Returns true if the given `string` contains the given pattern. Similar\n * to [.isMatch](#isMatch) but the pattern can match any part of the string.\n *\n * ```js\n * var mm = require('micromatch');\n * // mm.contains(string, pattern[, options]);\n *\n * console.log(mm.contains('aa/bb/cc', '*b'));\n * //=> true\n * console.log(mm.contains('aa/bb/cc', '*d'));\n * //=> false\n * ```\n * @param {String} `str` The string to match.\n * @param {String|Array} `patterns` Glob pattern to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if any of the patterns matches any part of `str`.\n * @api public\n */\n\nmicromatch.contains = (str, pattern, options) => {\n  if (typeof str !== 'string') {\n    throw new TypeError(`Expected a string: \"${util.inspect(str)}\"`);\n  }\n\n  if (Array.isArray(pattern)) {\n    return pattern.some(p => micromatch.contains(str, p, options));\n  }\n\n  if (typeof pattern === 'string') {\n    if (isEmptyString(str) || isEmptyString(pattern)) {\n      return false;\n    }\n\n    if (str.includes(pattern) || (str.startsWith('./') && str.slice(2).includes(pattern))) {\n      return true;\n    }\n  }\n\n  return micromatch.isMatch(str, pattern, { ...options, contains: true });\n};\n\n/**\n * Filter the keys of the given object with the given `glob` pattern\n * and `options`. Does not attempt to match nested keys. If you need this feature,\n * use [glob-object][] instead.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.matchKeys(object, patterns[, options]);\n *\n * const obj = { aa: 'a', ab: 'b', ac: 'c' };\n * console.log(mm.matchKeys(obj, '*b'));\n * //=> { ab: 'b' }\n * ```\n * @param {Object} `object` The object with keys to filter.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Object} Returns an object with only keys that match the given patterns.\n * @api public\n */\n\nmicromatch.matchKeys = (obj, patterns, options) => {\n  if (!utils.isObject(obj)) {\n    throw new TypeError('Expected the first argument to be an object');\n  }\n  let keys = micromatch(Object.keys(obj), patterns, options);\n  let res = {};\n  for (let key of keys) res[key] = obj[key];\n  return res;\n};\n\n/**\n * Returns true if some of the strings in the given `list` match any of the given glob `patterns`.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.some(list, patterns[, options]);\n *\n * console.log(mm.some(['foo.js', 'bar.js'], ['*.js', '!foo.js']));\n * // true\n * console.log(mm.some(['foo.js'], ['*.js', '!foo.js']));\n * // false\n * ```\n * @param {String|Array} `list` The string or array of strings to test. Returns as soon as the first match is found.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if any `patterns` matches any of the strings in `list`\n * @api public\n */\n\nmicromatch.some = (list, patterns, options) => {\n  let items = [].concat(list);\n\n  for (let pattern of [].concat(patterns)) {\n    let isMatch = picomatch(String(pattern), options);\n    if (items.some(item => isMatch(item))) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n * Returns true if every string in the given `list` matches\n * any of the given glob `patterns`.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.every(list, patterns[, options]);\n *\n * console.log(mm.every('foo.js', ['foo.js']));\n * // true\n * console.log(mm.every(['foo.js', 'bar.js'], ['*.js']));\n * // true\n * console.log(mm.every(['foo.js', 'bar.js'], ['*.js', '!foo.js']));\n * // false\n * console.log(mm.every(['foo.js'], ['*.js', '!foo.js']));\n * // false\n * ```\n * @param {String|Array} `list` The string or array of strings to test.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if all `patterns` matches all of the strings in `list`\n * @api public\n */\n\nmicromatch.every = (list, patterns, options) => {\n  let items = [].concat(list);\n\n  for (let pattern of [].concat(patterns)) {\n    let isMatch = picomatch(String(pattern), options);\n    if (!items.every(item => isMatch(item))) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Returns true if **all** of the given `patterns` match\n * the specified string.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.all(string, patterns[, options]);\n *\n * console.log(mm.all('foo.js', ['foo.js']));\n * // true\n *\n * console.log(mm.all('foo.js', ['*.js', '!foo.js']));\n * // false\n *\n * console.log(mm.all('foo.js', ['*.js', 'foo.js']));\n * // true\n *\n * console.log(mm.all('foo.js', ['*.js', 'f*', '*o*', '*o.js']));\n * // true\n * ```\n * @param {String|Array} `str` The string to test.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\n\nmicromatch.all = (str, patterns, options) => {\n  if (typeof str !== 'string') {\n    throw new TypeError(`Expected a string: \"${util.inspect(str)}\"`);\n  }\n\n  return [].concat(patterns).every(p => picomatch(p, options)(str));\n};\n\n/**\n * Returns an array of matches captured by `pattern` in `string, or `null` if the pattern did not match.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.capture(pattern, string[, options]);\n *\n * console.log(mm.capture('test/*.js', 'test/foo.js'));\n * //=> ['foo']\n * console.log(mm.capture('test/*.js', 'foo/bar.css'));\n * //=> null\n * ```\n * @param {String} `glob` Glob pattern to use for matching.\n * @param {String} `input` String to match\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Array|null} Returns an array of captures if the input matches the glob pattern, otherwise `null`.\n * @api public\n */\n\nmicromatch.capture = (glob, input, options) => {\n  let posix = utils.isWindows(options);\n  let regex = picomatch.makeRe(String(glob), { ...options, capture: true });\n  let match = regex.exec(posix ? utils.toPosixSlashes(input) : input);\n\n  if (match) {\n    return match.slice(1).map(v => v === void 0 ? '' : v);\n  }\n};\n\n/**\n * Create a regular expression from the given glob `pattern`.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.makeRe(pattern[, options]);\n *\n * console.log(mm.makeRe('*.js'));\n * //=> /^(?:(\\.[\\\\\\/])?(?!\\.)(?=.)[^\\/]*?\\.js)$/\n * ```\n * @param {String} `pattern` A glob pattern to convert to regex.\n * @param {Object} `options`\n * @return {RegExp} Returns a regex created from the given pattern.\n * @api public\n */\n\nmicromatch.makeRe = (...args) => picomatch.makeRe(...args);\n\n/**\n * Scan a glob pattern to separate the pattern into segments. Used\n * by the [split](#split) method.\n *\n * ```js\n * const mm = require('micromatch');\n * const state = mm.scan(pattern[, options]);\n * ```\n * @param {String} `pattern`\n * @param {Object} `options`\n * @return {Object} Returns an object with\n * @api public\n */\n\nmicromatch.scan = (...args) => picomatch.scan(...args);\n\n/**\n * Parse a glob pattern to create the source string for a regular\n * expression.\n *\n * ```js\n * const mm = require('micromatch');\n * const state = mm.parse(pattern[, options]);\n * ```\n * @param {String} `glob`\n * @param {Object} `options`\n * @return {Object} Returns an object with useful properties and output to be used as regex source string.\n * @api public\n */\n\nmicromatch.parse = (patterns, options) => {\n  let res = [];\n  for (let pattern of [].concat(patterns || [])) {\n    for (let str of braces(String(pattern), options)) {\n      res.push(picomatch.parse(str, options));\n    }\n  }\n  return res;\n};\n\n/**\n * Process the given brace `pattern`.\n *\n * ```js\n * const { braces } = require('micromatch');\n * console.log(braces('foo/{a,b,c}/bar'));\n * //=> [ 'foo/(a|b|c)/bar' ]\n *\n * console.log(braces('foo/{a,b,c}/bar', { expand: true }));\n * //=> [ 'foo/a/bar', 'foo/b/bar', 'foo/c/bar' ]\n * ```\n * @param {String} `pattern` String with brace pattern to process.\n * @param {Object} `options` Any [options](#options) to change how expansion is performed. See the [braces][] library for all available options.\n * @return {Array}\n * @api public\n */\n\nmicromatch.braces = (pattern, options) => {\n  if (typeof pattern !== 'string') throw new TypeError('Expected a string');\n  if ((options && options.nobrace === true) || !/\\{.*\\}/.test(pattern)) {\n    return [pattern];\n  }\n  return braces(pattern, options);\n};\n\n/**\n * Expand braces\n */\n\nmicromatch.braceExpand = (pattern, options) => {\n  if (typeof pattern !== 'string') throw new TypeError('Expected a string');\n  return micromatch.braces(pattern, { ...options, expand: true });\n};\n\n/**\n * Expose micromatch\n */\n\nmodule.exports = micromatch;\n","'use strict';\n\nmodule.exports = require('./lib/picomatch');\n","'use strict';\n\nconst path = require('path');\nconst WIN_SLASH = '\\\\\\\\/';\nconst WIN_NO_SLASH = `[^${WIN_SLASH}]`;\n\n/**\n * Posix glob regex\n */\n\nconst DOT_LITERAL = '\\\\.';\nconst PLUS_LITERAL = '\\\\+';\nconst QMARK_LITERAL = '\\\\?';\nconst SLASH_LITERAL = '\\\\/';\nconst ONE_CHAR = '(?=.)';\nconst QMARK = '[^/]';\nconst END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;\nconst START_ANCHOR = `(?:^|${SLASH_LITERAL})`;\nconst DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;\nconst NO_DOT = `(?!${DOT_LITERAL})`;\nconst NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;\nconst NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;\nconst NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;\nconst QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;\nconst STAR = `${QMARK}*?`;\n\nconst POSIX_CHARS = {\n  DOT_LITERAL,\n  PLUS_LITERAL,\n  QMARK_LITERAL,\n  SLASH_LITERAL,\n  ONE_CHAR,\n  QMARK,\n  END_ANCHOR,\n  DOTS_SLASH,\n  NO_DOT,\n  NO_DOTS,\n  NO_DOT_SLASH,\n  NO_DOTS_SLASH,\n  QMARK_NO_DOT,\n  STAR,\n  START_ANCHOR\n};\n\n/**\n * Windows glob regex\n */\n\nconst WINDOWS_CHARS = {\n  ...POSIX_CHARS,\n\n  SLASH_LITERAL: `[${WIN_SLASH}]`,\n  QMARK: WIN_NO_SLASH,\n  STAR: `${WIN_NO_SLASH}*?`,\n  DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,\n  NO_DOT: `(?!${DOT_LITERAL})`,\n  NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,\n  NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,\n  NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,\n  QMARK_NO_DOT: `[^.${WIN_SLASH}]`,\n  START_ANCHOR: `(?:^|[${WIN_SLASH}])`,\n  END_ANCHOR: `(?:[${WIN_SLASH}]|$)`\n};\n\n/**\n * POSIX Bracket Regex\n */\n\nconst POSIX_REGEX_SOURCE = {\n  alnum: 'a-zA-Z0-9',\n  alpha: 'a-zA-Z',\n  ascii: '\\\\x00-\\\\x7F',\n  blank: ' \\\\t',\n  cntrl: '\\\\x00-\\\\x1F\\\\x7F',\n  digit: '0-9',\n  graph: '\\\\x21-\\\\x7E',\n  lower: 'a-z',\n  print: '\\\\x20-\\\\x7E ',\n  punct: '\\\\-!\"#$%&\\'()\\\\*+,./:;<=>?@[\\\\]^_`{|}~',\n  space: ' \\\\t\\\\r\\\\n\\\\v\\\\f',\n  upper: 'A-Z',\n  word: 'A-Za-z0-9_',\n  xdigit: 'A-Fa-f0-9'\n};\n\nmodule.exports = {\n  MAX_LENGTH: 1024 * 64,\n  POSIX_REGEX_SOURCE,\n\n  // regular expressions\n  REGEX_BACKSLASH: /\\\\(?![*+?^${}(|)[\\]])/g,\n  REGEX_NON_SPECIAL_CHARS: /^[^@![\\].,$*+?^{}()|\\\\/]+/,\n  REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\\]]/,\n  REGEX_SPECIAL_CHARS_BACKREF: /(\\\\?)((\\W)(\\3*))/g,\n  REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\\]])/g,\n  REGEX_REMOVE_BACKSLASH: /(?:\\[.*?[^\\\\]\\]|\\\\(?=.))/g,\n\n  // Replace globs with equivalent patterns to reduce parsing time.\n  REPLACEMENTS: {\n    '***': '*',\n    '**/**': '**',\n    '**/**/**': '**'\n  },\n\n  // Digits\n  CHAR_0: 48, /* 0 */\n  CHAR_9: 57, /* 9 */\n\n  // Alphabet chars.\n  CHAR_UPPERCASE_A: 65, /* A */\n  CHAR_LOWERCASE_A: 97, /* a */\n  CHAR_UPPERCASE_Z: 90, /* Z */\n  CHAR_LOWERCASE_Z: 122, /* z */\n\n  CHAR_LEFT_PARENTHESES: 40, /* ( */\n  CHAR_RIGHT_PARENTHESES: 41, /* ) */\n\n  CHAR_ASTERISK: 42, /* * */\n\n  // Non-alphabetic chars.\n  CHAR_AMPERSAND: 38, /* & */\n  CHAR_AT: 64, /* @ */\n  CHAR_BACKWARD_SLASH: 92, /* \\ */\n  CHAR_CARRIAGE_RETURN: 13, /* \\r */\n  CHAR_CIRCUMFLEX_ACCENT: 94, /* ^ */\n  CHAR_COLON: 58, /* : */\n  CHAR_COMMA: 44, /* , */\n  CHAR_DOT: 46, /* . */\n  CHAR_DOUBLE_QUOTE: 34, /* \" */\n  CHAR_EQUAL: 61, /* = */\n  CHAR_EXCLAMATION_MARK: 33, /* ! */\n  CHAR_FORM_FEED: 12, /* \\f */\n  CHAR_FORWARD_SLASH: 47, /* / */\n  CHAR_GRAVE_ACCENT: 96, /* ` */\n  CHAR_HASH: 35, /* # */\n  CHAR_HYPHEN_MINUS: 45, /* - */\n  CHAR_LEFT_ANGLE_BRACKET: 60, /* < */\n  CHAR_LEFT_CURLY_BRACE: 123, /* { */\n  CHAR_LEFT_SQUARE_BRACKET: 91, /* [ */\n  CHAR_LINE_FEED: 10, /* \\n */\n  CHAR_NO_BREAK_SPACE: 160, /* \\u00A0 */\n  CHAR_PERCENT: 37, /* % */\n  CHAR_PLUS: 43, /* + */\n  CHAR_QUESTION_MARK: 63, /* ? */\n  CHAR_RIGHT_ANGLE_BRACKET: 62, /* > */\n  CHAR_RIGHT_CURLY_BRACE: 125, /* } */\n  CHAR_RIGHT_SQUARE_BRACKET: 93, /* ] */\n  CHAR_SEMICOLON: 59, /* ; */\n  CHAR_SINGLE_QUOTE: 39, /* ' */\n  CHAR_SPACE: 32, /*   */\n  CHAR_TAB: 9, /* \\t */\n  CHAR_UNDERSCORE: 95, /* _ */\n  CHAR_VERTICAL_LINE: 124, /* | */\n  CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279, /* \\uFEFF */\n\n  SEP: path.sep,\n\n  /**\n   * Create EXTGLOB_CHARS\n   */\n\n  extglobChars(chars) {\n    return {\n      '!': { type: 'negate', open: '(?:(?!(?:', close: `))${chars.STAR})` },\n      '?': { type: 'qmark', open: '(?:', close: ')?' },\n      '+': { type: 'plus', open: '(?:', close: ')+' },\n      '*': { type: 'star', open: '(?:', close: ')*' },\n      '@': { type: 'at', open: '(?:', close: ')' }\n    };\n  },\n\n  /**\n   * Create GLOB_CHARS\n   */\n\n  globChars(win32) {\n    return win32 === true ? WINDOWS_CHARS : POSIX_CHARS;\n  }\n};\n","'use strict';\n\nconst constants = require('./constants');\nconst utils = require('./utils');\n\n/**\n * Constants\n */\n\nconst {\n  MAX_LENGTH,\n  POSIX_REGEX_SOURCE,\n  REGEX_NON_SPECIAL_CHARS,\n  REGEX_SPECIAL_CHARS_BACKREF,\n  REPLACEMENTS\n} = constants;\n\n/**\n * Helpers\n */\n\nconst expandRange = (args, options) => {\n  if (typeof options.expandRange === 'function') {\n    return options.expandRange(...args, options);\n  }\n\n  args.sort();\n  const value = `[${args.join('-')}]`;\n\n  try {\n    /* eslint-disable-next-line no-new */\n    new RegExp(value);\n  } catch (ex) {\n    return args.map(v => utils.escapeRegex(v)).join('..');\n  }\n\n  return value;\n};\n\n/**\n * Create the message for a syntax error\n */\n\nconst syntaxError = (type, char) => {\n  return `Missing ${type}: \"${char}\" - use \"\\\\\\\\${char}\" to match literal characters`;\n};\n\n/**\n * Parse the given input string.\n * @param {String} input\n * @param {Object} options\n * @return {Object}\n */\n\nconst parse = (input, options) => {\n  if (typeof input !== 'string') {\n    throw new TypeError('Expected a string');\n  }\n\n  input = REPLACEMENTS[input] || input;\n\n  const opts = { ...options };\n  const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;\n\n  let len = input.length;\n  if (len > max) {\n    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);\n  }\n\n  const bos = { type: 'bos', value: '', output: opts.prepend || '' };\n  const tokens = [bos];\n\n  const capture = opts.capture ? '' : '?:';\n  const win32 = utils.isWindows(options);\n\n  // create constants based on platform, for windows or posix\n  const PLATFORM_CHARS = constants.globChars(win32);\n  const EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);\n\n  const {\n    DOT_LITERAL,\n    PLUS_LITERAL,\n    SLASH_LITERAL,\n    ONE_CHAR,\n    DOTS_SLASH,\n    NO_DOT,\n    NO_DOT_SLASH,\n    NO_DOTS_SLASH,\n    QMARK,\n    QMARK_NO_DOT,\n    STAR,\n    START_ANCHOR\n  } = PLATFORM_CHARS;\n\n  const globstar = opts => {\n    return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;\n  };\n\n  const nodot = opts.dot ? '' : NO_DOT;\n  const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;\n  let star = opts.bash === true ? globstar(opts) : STAR;\n\n  if (opts.capture) {\n    star = `(${star})`;\n  }\n\n  // minimatch options support\n  if (typeof opts.noext === 'boolean') {\n    opts.noextglob = opts.noext;\n  }\n\n  const state = {\n    input,\n    index: -1,\n    start: 0,\n    dot: opts.dot === true,\n    consumed: '',\n    output: '',\n    prefix: '',\n    backtrack: false,\n    negated: false,\n    brackets: 0,\n    braces: 0,\n    parens: 0,\n    quotes: 0,\n    globstar: false,\n    tokens\n  };\n\n  input = utils.removePrefix(input, state);\n  len = input.length;\n\n  const extglobs = [];\n  const braces = [];\n  const stack = [];\n  let prev = bos;\n  let value;\n\n  /**\n   * Tokenizing helpers\n   */\n\n  const eos = () => state.index === len - 1;\n  const peek = state.peek = (n = 1) => input[state.index + n];\n  const advance = state.advance = () => input[++state.index] || '';\n  const remaining = () => input.slice(state.index + 1);\n  const consume = (value = '', num = 0) => {\n    state.consumed += value;\n    state.index += num;\n  };\n\n  const append = token => {\n    state.output += token.output != null ? token.output : token.value;\n    consume(token.value);\n  };\n\n  const negate = () => {\n    let count = 1;\n\n    while (peek() === '!' && (peek(2) !== '(' || peek(3) === '?')) {\n      advance();\n      state.start++;\n      count++;\n    }\n\n    if (count % 2 === 0) {\n      return false;\n    }\n\n    state.negated = true;\n    state.start++;\n    return true;\n  };\n\n  const increment = type => {\n    state[type]++;\n    stack.push(type);\n  };\n\n  const decrement = type => {\n    state[type]--;\n    stack.pop();\n  };\n\n  /**\n   * Push tokens onto the tokens array. This helper speeds up\n   * tokenizing by 1) helping us avoid backtracking as much as possible,\n   * and 2) helping us avoid creating extra tokens when consecutive\n   * characters are plain text. This improves performance and simplifies\n   * lookbehinds.\n   */\n\n  const push = tok => {\n    if (prev.type === 'globstar') {\n      const isBrace = state.braces > 0 && (tok.type === 'comma' || tok.type === 'brace');\n      const isExtglob = tok.extglob === true || (extglobs.length && (tok.type === 'pipe' || tok.type === 'paren'));\n\n      if (tok.type !== 'slash' && tok.type !== 'paren' && !isBrace && !isExtglob) {\n        state.output = state.output.slice(0, -prev.output.length);\n        prev.type = 'star';\n        prev.value = '*';\n        prev.output = star;\n        state.output += prev.output;\n      }\n    }\n\n    if (extglobs.length && tok.type !== 'paren') {\n      extglobs[extglobs.length - 1].inner += tok.value;\n    }\n\n    if (tok.value || tok.output) append(tok);\n    if (prev && prev.type === 'text' && tok.type === 'text') {\n      prev.value += tok.value;\n      prev.output = (prev.output || '') + tok.value;\n      return;\n    }\n\n    tok.prev = prev;\n    tokens.push(tok);\n    prev = tok;\n  };\n\n  const extglobOpen = (type, value) => {\n    const token = { ...EXTGLOB_CHARS[value], conditions: 1, inner: '' };\n\n    token.prev = prev;\n    token.parens = state.parens;\n    token.output = state.output;\n    const output = (opts.capture ? '(' : '') + token.open;\n\n    increment('parens');\n    push({ type, value, output: state.output ? '' : ONE_CHAR });\n    push({ type: 'paren', extglob: true, value: advance(), output });\n    extglobs.push(token);\n  };\n\n  const extglobClose = token => {\n    let output = token.close + (opts.capture ? ')' : '');\n    let rest;\n\n    if (token.type === 'negate') {\n      let extglobStar = star;\n\n      if (token.inner && token.inner.length > 1 && token.inner.includes('/')) {\n        extglobStar = globstar(opts);\n      }\n\n      if (extglobStar !== star || eos() || /^\\)+$/.test(remaining())) {\n        output = token.close = `)$))${extglobStar}`;\n      }\n\n      if (token.inner.includes('*') && (rest = remaining()) && /^\\.[^\\\\/.]+$/.test(rest)) {\n        // Any non-magical string (`.ts`) or even nested expression (`.{ts,tsx}`) can follow after the closing parenthesis.\n        // In this case, we need to parse the string and use it in the output of the original pattern.\n        // Suitable patterns: `/!(*.d).ts`, `/!(*.d).{ts,tsx}`, `**/!(*-dbg).@(js)`.\n        //\n        // Disabling the `fastpaths` option due to a problem with parsing strings as `.ts` in the pattern like `**/!(*.d).ts`.\n        const expression = parse(rest, { ...options, fastpaths: false }).output;\n\n        output = token.close = `)${expression})${extglobStar})`;\n      }\n\n      if (token.prev.type === 'bos') {\n        state.negatedExtglob = true;\n      }\n    }\n\n    push({ type: 'paren', extglob: true, value, output });\n    decrement('parens');\n  };\n\n  /**\n   * Fast paths\n   */\n\n  if (opts.fastpaths !== false && !/(^[*!]|[/()[\\]{}\"])/.test(input)) {\n    let backslashes = false;\n\n    let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index) => {\n      if (first === '\\\\') {\n        backslashes = true;\n        return m;\n      }\n\n      if (first === '?') {\n        if (esc) {\n          return esc + first + (rest ? QMARK.repeat(rest.length) : '');\n        }\n        if (index === 0) {\n          return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : '');\n        }\n        return QMARK.repeat(chars.length);\n      }\n\n      if (first === '.') {\n        return DOT_LITERAL.repeat(chars.length);\n      }\n\n      if (first === '*') {\n        if (esc) {\n          return esc + first + (rest ? star : '');\n        }\n        return star;\n      }\n      return esc ? m : `\\\\${m}`;\n    });\n\n    if (backslashes === true) {\n      if (opts.unescape === true) {\n        output = output.replace(/\\\\/g, '');\n      } else {\n        output = output.replace(/\\\\+/g, m => {\n          return m.length % 2 === 0 ? '\\\\\\\\' : (m ? '\\\\' : '');\n        });\n      }\n    }\n\n    if (output === input && opts.contains === true) {\n      state.output = input;\n      return state;\n    }\n\n    state.output = utils.wrapOutput(output, state, options);\n    return state;\n  }\n\n  /**\n   * Tokenize input until we reach end-of-string\n   */\n\n  while (!eos()) {\n    value = advance();\n\n    if (value === '\\u0000') {\n      continue;\n    }\n\n    /**\n     * Escaped characters\n     */\n\n    if (value === '\\\\') {\n      const next = peek();\n\n      if (next === '/' && opts.bash !== true) {\n        continue;\n      }\n\n      if (next === '.' || next === ';') {\n        continue;\n      }\n\n      if (!next) {\n        value += '\\\\';\n        push({ type: 'text', value });\n        continue;\n      }\n\n      // collapse slashes to reduce potential for exploits\n      const match = /^\\\\+/.exec(remaining());\n      let slashes = 0;\n\n      if (match && match[0].length > 2) {\n        slashes = match[0].length;\n        state.index += slashes;\n        if (slashes % 2 !== 0) {\n          value += '\\\\';\n        }\n      }\n\n      if (opts.unescape === true) {\n        value = advance();\n      } else {\n        value += advance();\n      }\n\n      if (state.brackets === 0) {\n        push({ type: 'text', value });\n        continue;\n      }\n    }\n\n    /**\n     * If we're inside a regex character class, continue\n     * until we reach the closing bracket.\n     */\n\n    if (state.brackets > 0 && (value !== ']' || prev.value === '[' || prev.value === '[^')) {\n      if (opts.posix !== false && value === ':') {\n        const inner = prev.value.slice(1);\n        if (inner.includes('[')) {\n          prev.posix = true;\n\n          if (inner.includes(':')) {\n            const idx = prev.value.lastIndexOf('[');\n            const pre = prev.value.slice(0, idx);\n            const rest = prev.value.slice(idx + 2);\n            const posix = POSIX_REGEX_SOURCE[rest];\n            if (posix) {\n              prev.value = pre + posix;\n              state.backtrack = true;\n              advance();\n\n              if (!bos.output && tokens.indexOf(prev) === 1) {\n                bos.output = ONE_CHAR;\n              }\n              continue;\n            }\n          }\n        }\n      }\n\n      if ((value === '[' && peek() !== ':') || (value === '-' && peek() === ']')) {\n        value = `\\\\${value}`;\n      }\n\n      if (value === ']' && (prev.value === '[' || prev.value === '[^')) {\n        value = `\\\\${value}`;\n      }\n\n      if (opts.posix === true && value === '!' && prev.value === '[') {\n        value = '^';\n      }\n\n      prev.value += value;\n      append({ value });\n      continue;\n    }\n\n    /**\n     * If we're inside a quoted string, continue\n     * until we reach the closing double quote.\n     */\n\n    if (state.quotes === 1 && value !== '\"') {\n      value = utils.escapeRegex(value);\n      prev.value += value;\n      append({ value });\n      continue;\n    }\n\n    /**\n     * Double quotes\n     */\n\n    if (value === '\"') {\n      state.quotes = state.quotes === 1 ? 0 : 1;\n      if (opts.keepQuotes === true) {\n        push({ type: 'text', value });\n      }\n      continue;\n    }\n\n    /**\n     * Parentheses\n     */\n\n    if (value === '(') {\n      increment('parens');\n      push({ type: 'paren', value });\n      continue;\n    }\n\n    if (value === ')') {\n      if (state.parens === 0 && opts.strictBrackets === true) {\n        throw new SyntaxError(syntaxError('opening', '('));\n      }\n\n      const extglob = extglobs[extglobs.length - 1];\n      if (extglob && state.parens === extglob.parens + 1) {\n        extglobClose(extglobs.pop());\n        continue;\n      }\n\n      push({ type: 'paren', value, output: state.parens ? ')' : '\\\\)' });\n      decrement('parens');\n      continue;\n    }\n\n    /**\n     * Square brackets\n     */\n\n    if (value === '[') {\n      if (opts.nobracket === true || !remaining().includes(']')) {\n        if (opts.nobracket !== true && opts.strictBrackets === true) {\n          throw new SyntaxError(syntaxError('closing', ']'));\n        }\n\n        value = `\\\\${value}`;\n      } else {\n        increment('brackets');\n      }\n\n      push({ type: 'bracket', value });\n      continue;\n    }\n\n    if (value === ']') {\n      if (opts.nobracket === true || (prev && prev.type === 'bracket' && prev.value.length === 1)) {\n        push({ type: 'text', value, output: `\\\\${value}` });\n        continue;\n      }\n\n      if (state.brackets === 0) {\n        if (opts.strictBrackets === true) {\n          throw new SyntaxError(syntaxError('opening', '['));\n        }\n\n        push({ type: 'text', value, output: `\\\\${value}` });\n        continue;\n      }\n\n      decrement('brackets');\n\n      const prevValue = prev.value.slice(1);\n      if (prev.posix !== true && prevValue[0] === '^' && !prevValue.includes('/')) {\n        value = `/${value}`;\n      }\n\n      prev.value += value;\n      append({ value });\n\n      // when literal brackets are explicitly disabled\n      // assume we should match with a regex character class\n      if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {\n        continue;\n      }\n\n      const escaped = utils.escapeRegex(prev.value);\n      state.output = state.output.slice(0, -prev.value.length);\n\n      // when literal brackets are explicitly enabled\n      // assume we should escape the brackets to match literal characters\n      if (opts.literalBrackets === true) {\n        state.output += escaped;\n        prev.value = escaped;\n        continue;\n      }\n\n      // when the user specifies nothing, try to match both\n      prev.value = `(${capture}${escaped}|${prev.value})`;\n      state.output += prev.value;\n      continue;\n    }\n\n    /**\n     * Braces\n     */\n\n    if (value === '{' && opts.nobrace !== true) {\n      increment('braces');\n\n      const open = {\n        type: 'brace',\n        value,\n        output: '(',\n        outputIndex: state.output.length,\n        tokensIndex: state.tokens.length\n      };\n\n      braces.push(open);\n      push(open);\n      continue;\n    }\n\n    if (value === '}') {\n      const brace = braces[braces.length - 1];\n\n      if (opts.nobrace === true || !brace) {\n        push({ type: 'text', value, output: value });\n        continue;\n      }\n\n      let output = ')';\n\n      if (brace.dots === true) {\n        const arr = tokens.slice();\n        const range = [];\n\n        for (let i = arr.length - 1; i >= 0; i--) {\n          tokens.pop();\n          if (arr[i].type === 'brace') {\n            break;\n          }\n          if (arr[i].type !== 'dots') {\n            range.unshift(arr[i].value);\n          }\n        }\n\n        output = expandRange(range, opts);\n        state.backtrack = true;\n      }\n\n      if (brace.comma !== true && brace.dots !== true) {\n        const out = state.output.slice(0, brace.outputIndex);\n        const toks = state.tokens.slice(brace.tokensIndex);\n        brace.value = brace.output = '\\\\{';\n        value = output = '\\\\}';\n        state.output = out;\n        for (const t of toks) {\n          state.output += (t.output || t.value);\n        }\n      }\n\n      push({ type: 'brace', value, output });\n      decrement('braces');\n      braces.pop();\n      continue;\n    }\n\n    /**\n     * Pipes\n     */\n\n    if (value === '|') {\n      if (extglobs.length > 0) {\n        extglobs[extglobs.length - 1].conditions++;\n      }\n      push({ type: 'text', value });\n      continue;\n    }\n\n    /**\n     * Commas\n     */\n\n    if (value === ',') {\n      let output = value;\n\n      const brace = braces[braces.length - 1];\n      if (brace && stack[stack.length - 1] === 'braces') {\n        brace.comma = true;\n        output = '|';\n      }\n\n      push({ type: 'comma', value, output });\n      continue;\n    }\n\n    /**\n     * Slashes\n     */\n\n    if (value === '/') {\n      // if the beginning of the glob is \"./\", advance the start\n      // to the current index, and don't add the \"./\" characters\n      // to the state. This greatly simplifies lookbehinds when\n      // checking for BOS characters like \"!\" and \".\" (not \"./\")\n      if (prev.type === 'dot' && state.index === state.start + 1) {\n        state.start = state.index + 1;\n        state.consumed = '';\n        state.output = '';\n        tokens.pop();\n        prev = bos; // reset \"prev\" to the first token\n        continue;\n      }\n\n      push({ type: 'slash', value, output: SLASH_LITERAL });\n      continue;\n    }\n\n    /**\n     * Dots\n     */\n\n    if (value === '.') {\n      if (state.braces > 0 && prev.type === 'dot') {\n        if (prev.value === '.') prev.output = DOT_LITERAL;\n        const brace = braces[braces.length - 1];\n        prev.type = 'dots';\n        prev.output += value;\n        prev.value += value;\n        brace.dots = true;\n        continue;\n      }\n\n      if ((state.braces + state.parens) === 0 && prev.type !== 'bos' && prev.type !== 'slash') {\n        push({ type: 'text', value, output: DOT_LITERAL });\n        continue;\n      }\n\n      push({ type: 'dot', value, output: DOT_LITERAL });\n      continue;\n    }\n\n    /**\n     * Question marks\n     */\n\n    if (value === '?') {\n      const isGroup = prev && prev.value === '(';\n      if (!isGroup && opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n        extglobOpen('qmark', value);\n        continue;\n      }\n\n      if (prev && prev.type === 'paren') {\n        const next = peek();\n        let output = value;\n\n        if (next === '<' && !utils.supportsLookbehinds()) {\n          throw new Error('Node.js v10 or higher is required for regex lookbehinds');\n        }\n\n        if ((prev.value === '(' && !/[!=<:]/.test(next)) || (next === '<' && !/<([!=]|\\w+>)/.test(remaining()))) {\n          output = `\\\\${value}`;\n        }\n\n        push({ type: 'text', value, output });\n        continue;\n      }\n\n      if (opts.dot !== true && (prev.type === 'slash' || prev.type === 'bos')) {\n        push({ type: 'qmark', value, output: QMARK_NO_DOT });\n        continue;\n      }\n\n      push({ type: 'qmark', value, output: QMARK });\n      continue;\n    }\n\n    /**\n     * Exclamation\n     */\n\n    if (value === '!') {\n      if (opts.noextglob !== true && peek() === '(') {\n        if (peek(2) !== '?' || !/[!=<:]/.test(peek(3))) {\n          extglobOpen('negate', value);\n          continue;\n        }\n      }\n\n      if (opts.nonegate !== true && state.index === 0) {\n        negate();\n        continue;\n      }\n    }\n\n    /**\n     * Plus\n     */\n\n    if (value === '+') {\n      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n        extglobOpen('plus', value);\n        continue;\n      }\n\n      if ((prev && prev.value === '(') || opts.regex === false) {\n        push({ type: 'plus', value, output: PLUS_LITERAL });\n        continue;\n      }\n\n      if ((prev && (prev.type === 'bracket' || prev.type === 'paren' || prev.type === 'brace')) || state.parens > 0) {\n        push({ type: 'plus', value });\n        continue;\n      }\n\n      push({ type: 'plus', value: PLUS_LITERAL });\n      continue;\n    }\n\n    /**\n     * Plain text\n     */\n\n    if (value === '@') {\n      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n        push({ type: 'at', extglob: true, value, output: '' });\n        continue;\n      }\n\n      push({ type: 'text', value });\n      continue;\n    }\n\n    /**\n     * Plain text\n     */\n\n    if (value !== '*') {\n      if (value === '$' || value === '^') {\n        value = `\\\\${value}`;\n      }\n\n      const match = REGEX_NON_SPECIAL_CHARS.exec(remaining());\n      if (match) {\n        value += match[0];\n        state.index += match[0].length;\n      }\n\n      push({ type: 'text', value });\n      continue;\n    }\n\n    /**\n     * Stars\n     */\n\n    if (prev && (prev.type === 'globstar' || prev.star === true)) {\n      prev.type = 'star';\n      prev.star = true;\n      prev.value += value;\n      prev.output = star;\n      state.backtrack = true;\n      state.globstar = true;\n      consume(value);\n      continue;\n    }\n\n    let rest = remaining();\n    if (opts.noextglob !== true && /^\\([^?]/.test(rest)) {\n      extglobOpen('star', value);\n      continue;\n    }\n\n    if (prev.type === 'star') {\n      if (opts.noglobstar === true) {\n        consume(value);\n        continue;\n      }\n\n      const prior = prev.prev;\n      const before = prior.prev;\n      const isStart = prior.type === 'slash' || prior.type === 'bos';\n      const afterStar = before && (before.type === 'star' || before.type === 'globstar');\n\n      if (opts.bash === true && (!isStart || (rest[0] && rest[0] !== '/'))) {\n        push({ type: 'star', value, output: '' });\n        continue;\n      }\n\n      const isBrace = state.braces > 0 && (prior.type === 'comma' || prior.type === 'brace');\n      const isExtglob = extglobs.length && (prior.type === 'pipe' || prior.type === 'paren');\n      if (!isStart && prior.type !== 'paren' && !isBrace && !isExtglob) {\n        push({ type: 'star', value, output: '' });\n        continue;\n      }\n\n      // strip consecutive `/**/`\n      while (rest.slice(0, 3) === '/**') {\n        const after = input[state.index + 4];\n        if (after && after !== '/') {\n          break;\n        }\n        rest = rest.slice(3);\n        consume('/**', 3);\n      }\n\n      if (prior.type === 'bos' && eos()) {\n        prev.type = 'globstar';\n        prev.value += value;\n        prev.output = globstar(opts);\n        state.output = prev.output;\n        state.globstar = true;\n        consume(value);\n        continue;\n      }\n\n      if (prior.type === 'slash' && prior.prev.type !== 'bos' && !afterStar && eos()) {\n        state.output = state.output.slice(0, -(prior.output + prev.output).length);\n        prior.output = `(?:${prior.output}`;\n\n        prev.type = 'globstar';\n        prev.output = globstar(opts) + (opts.strictSlashes ? ')' : '|$)');\n        prev.value += value;\n        state.globstar = true;\n        state.output += prior.output + prev.output;\n        consume(value);\n        continue;\n      }\n\n      if (prior.type === 'slash' && prior.prev.type !== 'bos' && rest[0] === '/') {\n        const end = rest[1] !== void 0 ? '|$' : '';\n\n        state.output = state.output.slice(0, -(prior.output + prev.output).length);\n        prior.output = `(?:${prior.output}`;\n\n        prev.type = 'globstar';\n        prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;\n        prev.value += value;\n\n        state.output += prior.output + prev.output;\n        state.globstar = true;\n\n        consume(value + advance());\n\n        push({ type: 'slash', value: '/', output: '' });\n        continue;\n      }\n\n      if (prior.type === 'bos' && rest[0] === '/') {\n        prev.type = 'globstar';\n        prev.value += value;\n        prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;\n        state.output = prev.output;\n        state.globstar = true;\n        consume(value + advance());\n        push({ type: 'slash', value: '/', output: '' });\n        continue;\n      }\n\n      // remove single star from output\n      state.output = state.output.slice(0, -prev.output.length);\n\n      // reset previous token to globstar\n      prev.type = 'globstar';\n      prev.output = globstar(opts);\n      prev.value += value;\n\n      // reset output with globstar\n      state.output += prev.output;\n      state.globstar = true;\n      consume(value);\n      continue;\n    }\n\n    const token = { type: 'star', value, output: star };\n\n    if (opts.bash === true) {\n      token.output = '.*?';\n      if (prev.type === 'bos' || prev.type === 'slash') {\n        token.output = nodot + token.output;\n      }\n      push(token);\n      continue;\n    }\n\n    if (prev && (prev.type === 'bracket' || prev.type === 'paren') && opts.regex === true) {\n      token.output = value;\n      push(token);\n      continue;\n    }\n\n    if (state.index === state.start || prev.type === 'slash' || prev.type === 'dot') {\n      if (prev.type === 'dot') {\n        state.output += NO_DOT_SLASH;\n        prev.output += NO_DOT_SLASH;\n\n      } else if (opts.dot === true) {\n        state.output += NO_DOTS_SLASH;\n        prev.output += NO_DOTS_SLASH;\n\n      } else {\n        state.output += nodot;\n        prev.output += nodot;\n      }\n\n      if (peek() !== '*') {\n        state.output += ONE_CHAR;\n        prev.output += ONE_CHAR;\n      }\n    }\n\n    push(token);\n  }\n\n  while (state.brackets > 0) {\n    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ']'));\n    state.output = utils.escapeLast(state.output, '[');\n    decrement('brackets');\n  }\n\n  while (state.parens > 0) {\n    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ')'));\n    state.output = utils.escapeLast(state.output, '(');\n    decrement('parens');\n  }\n\n  while (state.braces > 0) {\n    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', '}'));\n    state.output = utils.escapeLast(state.output, '{');\n    decrement('braces');\n  }\n\n  if (opts.strictSlashes !== true && (prev.type === 'star' || prev.type === 'bracket')) {\n    push({ type: 'maybe_slash', value: '', output: `${SLASH_LITERAL}?` });\n  }\n\n  // rebuild the output if we had to backtrack at any point\n  if (state.backtrack === true) {\n    state.output = '';\n\n    for (const token of state.tokens) {\n      state.output += token.output != null ? token.output : token.value;\n\n      if (token.suffix) {\n        state.output += token.suffix;\n      }\n    }\n  }\n\n  return state;\n};\n\n/**\n * Fast paths for creating regular expressions for common glob patterns.\n * This can significantly speed up processing and has very little downside\n * impact when none of the fast paths match.\n */\n\nparse.fastpaths = (input, options) => {\n  const opts = { ...options };\n  const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;\n  const len = input.length;\n  if (len > max) {\n    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);\n  }\n\n  input = REPLACEMENTS[input] || input;\n  const win32 = utils.isWindows(options);\n\n  // create constants based on platform, for windows or posix\n  const {\n    DOT_LITERAL,\n    SLASH_LITERAL,\n    ONE_CHAR,\n    DOTS_SLASH,\n    NO_DOT,\n    NO_DOTS,\n    NO_DOTS_SLASH,\n    STAR,\n    START_ANCHOR\n  } = constants.globChars(win32);\n\n  const nodot = opts.dot ? NO_DOTS : NO_DOT;\n  const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;\n  const capture = opts.capture ? '' : '?:';\n  const state = { negated: false, prefix: '' };\n  let star = opts.bash === true ? '.*?' : STAR;\n\n  if (opts.capture) {\n    star = `(${star})`;\n  }\n\n  const globstar = opts => {\n    if (opts.noglobstar === true) return star;\n    return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;\n  };\n\n  const create = str => {\n    switch (str) {\n      case '*':\n        return `${nodot}${ONE_CHAR}${star}`;\n\n      case '.*':\n        return `${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      case '*.*':\n        return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      case '*/*':\n        return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;\n\n      case '**':\n        return nodot + globstar(opts);\n\n      case '**/*':\n        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;\n\n      case '**/*.*':\n        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      case '**/.*':\n        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      default: {\n        const match = /^(.*?)\\.(\\w+)$/.exec(str);\n        if (!match) return;\n\n        const source = create(match[1]);\n        if (!source) return;\n\n        return source + DOT_LITERAL + match[2];\n      }\n    }\n  };\n\n  const output = utils.removePrefix(input, state);\n  let source = create(output);\n\n  if (source && opts.strictSlashes !== true) {\n    source += `${SLASH_LITERAL}?`;\n  }\n\n  return source;\n};\n\nmodule.exports = parse;\n","'use strict';\n\nconst path = require('path');\nconst scan = require('./scan');\nconst parse = require('./parse');\nconst utils = require('./utils');\nconst constants = require('./constants');\nconst isObject = val => val && typeof val === 'object' && !Array.isArray(val);\n\n/**\n * Creates a matcher function from one or more glob patterns. The\n * returned function takes a string to match as its first argument,\n * and returns true if the string is a match. The returned matcher\n * function also takes a boolean as the second argument that, when true,\n * returns an object with additional information.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch(glob[, options]);\n *\n * const isMatch = picomatch('*.!(*a)');\n * console.log(isMatch('a.a')); //=> false\n * console.log(isMatch('a.b')); //=> true\n * ```\n * @name picomatch\n * @param {String|Array} `globs` One or more glob patterns.\n * @param {Object=} `options`\n * @return {Function=} Returns a matcher function.\n * @api public\n */\n\nconst picomatch = (glob, options, returnState = false) => {\n  if (Array.isArray(glob)) {\n    const fns = glob.map(input => picomatch(input, options, returnState));\n    const arrayMatcher = str => {\n      for (const isMatch of fns) {\n        const state = isMatch(str);\n        if (state) return state;\n      }\n      return false;\n    };\n    return arrayMatcher;\n  }\n\n  const isState = isObject(glob) && glob.tokens && glob.input;\n\n  if (glob === '' || (typeof glob !== 'string' && !isState)) {\n    throw new TypeError('Expected pattern to be a non-empty string');\n  }\n\n  const opts = options || {};\n  const posix = utils.isWindows(options);\n  const regex = isState\n    ? picomatch.compileRe(glob, options)\n    : picomatch.makeRe(glob, options, false, true);\n\n  const state = regex.state;\n  delete regex.state;\n\n  let isIgnored = () => false;\n  if (opts.ignore) {\n    const ignoreOpts = { ...options, ignore: null, onMatch: null, onResult: null };\n    isIgnored = picomatch(opts.ignore, ignoreOpts, returnState);\n  }\n\n  const matcher = (input, returnObject = false) => {\n    const { isMatch, match, output } = picomatch.test(input, regex, options, { glob, posix });\n    const result = { glob, state, regex, posix, input, output, match, isMatch };\n\n    if (typeof opts.onResult === 'function') {\n      opts.onResult(result);\n    }\n\n    if (isMatch === false) {\n      result.isMatch = false;\n      return returnObject ? result : false;\n    }\n\n    if (isIgnored(input)) {\n      if (typeof opts.onIgnore === 'function') {\n        opts.onIgnore(result);\n      }\n      result.isMatch = false;\n      return returnObject ? result : false;\n    }\n\n    if (typeof opts.onMatch === 'function') {\n      opts.onMatch(result);\n    }\n    return returnObject ? result : true;\n  };\n\n  if (returnState) {\n    matcher.state = state;\n  }\n\n  return matcher;\n};\n\n/**\n * Test `input` with the given `regex`. This is used by the main\n * `picomatch()` function to test the input string.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.test(input, regex[, options]);\n *\n * console.log(picomatch.test('foo/bar', /^(?:([^/]*?)\\/([^/]*?))$/));\n * // { isMatch: true, match: [ 'foo/', 'foo', 'bar' ], output: 'foo/bar' }\n * ```\n * @param {String} `input` String to test.\n * @param {RegExp} `regex`\n * @return {Object} Returns an object with matching info.\n * @api public\n */\n\npicomatch.test = (input, regex, options, { glob, posix } = {}) => {\n  if (typeof input !== 'string') {\n    throw new TypeError('Expected input to be a string');\n  }\n\n  if (input === '') {\n    return { isMatch: false, output: '' };\n  }\n\n  const opts = options || {};\n  const format = opts.format || (posix ? utils.toPosixSlashes : null);\n  let match = input === glob;\n  let output = (match && format) ? format(input) : input;\n\n  if (match === false) {\n    output = format ? format(input) : input;\n    match = output === glob;\n  }\n\n  if (match === false || opts.capture === true) {\n    if (opts.matchBase === true || opts.basename === true) {\n      match = picomatch.matchBase(input, regex, options, posix);\n    } else {\n      match = regex.exec(output);\n    }\n  }\n\n  return { isMatch: Boolean(match), match, output };\n};\n\n/**\n * Match the basename of a filepath.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.matchBase(input, glob[, options]);\n * console.log(picomatch.matchBase('foo/bar.js', '*.js'); // true\n * ```\n * @param {String} `input` String to test.\n * @param {RegExp|String} `glob` Glob pattern or regex created by [.makeRe](#makeRe).\n * @return {Boolean}\n * @api public\n */\n\npicomatch.matchBase = (input, glob, options, posix = utils.isWindows(options)) => {\n  const regex = glob instanceof RegExp ? glob : picomatch.makeRe(glob, options);\n  return regex.test(path.basename(input));\n};\n\n/**\n * Returns true if **any** of the given glob `patterns` match the specified `string`.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.isMatch(string, patterns[, options]);\n *\n * console.log(picomatch.isMatch('a.a', ['b.*', '*.a'])); //=> true\n * console.log(picomatch.isMatch('a.a', 'b.*')); //=> false\n * ```\n * @param {String|Array} str The string to test.\n * @param {String|Array} patterns One or more glob patterns to use for matching.\n * @param {Object} [options] See available [options](#options).\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\n\npicomatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);\n\n/**\n * Parse a glob pattern to create the source string for a regular\n * expression.\n *\n * ```js\n * const picomatch = require('picomatch');\n * const result = picomatch.parse(pattern[, options]);\n * ```\n * @param {String} `pattern`\n * @param {Object} `options`\n * @return {Object} Returns an object with useful properties and output to be used as a regex source string.\n * @api public\n */\n\npicomatch.parse = (pattern, options) => {\n  if (Array.isArray(pattern)) return pattern.map(p => picomatch.parse(p, options));\n  return parse(pattern, { ...options, fastpaths: false });\n};\n\n/**\n * Scan a glob pattern to separate the pattern into segments.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.scan(input[, options]);\n *\n * const result = picomatch.scan('!./foo/*.js');\n * console.log(result);\n * { prefix: '!./',\n *   input: '!./foo/*.js',\n *   start: 3,\n *   base: 'foo',\n *   glob: '*.js',\n *   isBrace: false,\n *   isBracket: false,\n *   isGlob: true,\n *   isExtglob: false,\n *   isGlobstar: false,\n *   negated: true }\n * ```\n * @param {String} `input` Glob pattern to scan.\n * @param {Object} `options`\n * @return {Object} Returns an object with\n * @api public\n */\n\npicomatch.scan = (input, options) => scan(input, options);\n\n/**\n * Compile a regular expression from the `state` object returned by the\n * [parse()](#parse) method.\n *\n * @param {Object} `state`\n * @param {Object} `options`\n * @param {Boolean} `returnOutput` Intended for implementors, this argument allows you to return the raw output from the parser.\n * @param {Boolean} `returnState` Adds the state to a `state` property on the returned regex. Useful for implementors and debugging.\n * @return {RegExp}\n * @api public\n */\n\npicomatch.compileRe = (state, options, returnOutput = false, returnState = false) => {\n  if (returnOutput === true) {\n    return state.output;\n  }\n\n  const opts = options || {};\n  const prepend = opts.contains ? '' : '^';\n  const append = opts.contains ? '' : '$';\n\n  let source = `${prepend}(?:${state.output})${append}`;\n  if (state && state.negated === true) {\n    source = `^(?!${source}).*$`;\n  }\n\n  const regex = picomatch.toRegex(source, options);\n  if (returnState === true) {\n    regex.state = state;\n  }\n\n  return regex;\n};\n\n/**\n * Create a regular expression from a parsed glob pattern.\n *\n * ```js\n * const picomatch = require('picomatch');\n * const state = picomatch.parse('*.js');\n * // picomatch.compileRe(state[, options]);\n *\n * console.log(picomatch.compileRe(state));\n * //=> /^(?:(?!\\.)(?=.)[^/]*?\\.js)$/\n * ```\n * @param {String} `state` The object returned from the `.parse` method.\n * @param {Object} `options`\n * @param {Boolean} `returnOutput` Implementors may use this argument to return the compiled output, instead of a regular expression. This is not exposed on the options to prevent end-users from mutating the result.\n * @param {Boolean} `returnState` Implementors may use this argument to return the state from the parsed glob with the returned regular expression.\n * @return {RegExp} Returns a regex created from the given pattern.\n * @api public\n */\n\npicomatch.makeRe = (input, options = {}, returnOutput = false, returnState = false) => {\n  if (!input || typeof input !== 'string') {\n    throw new TypeError('Expected a non-empty string');\n  }\n\n  let parsed = { negated: false, fastpaths: true };\n\n  if (options.fastpaths !== false && (input[0] === '.' || input[0] === '*')) {\n    parsed.output = parse.fastpaths(input, options);\n  }\n\n  if (!parsed.output) {\n    parsed = parse(input, options);\n  }\n\n  return picomatch.compileRe(parsed, options, returnOutput, returnState);\n};\n\n/**\n * Create a regular expression from the given regex source string.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.toRegex(source[, options]);\n *\n * const { output } = picomatch.parse('*.js');\n * console.log(picomatch.toRegex(output));\n * //=> /^(?:(?!\\.)(?=.)[^/]*?\\.js)$/\n * ```\n * @param {String} `source` Regular expression source string.\n * @param {Object} `options`\n * @return {RegExp}\n * @api public\n */\n\npicomatch.toRegex = (source, options) => {\n  try {\n    const opts = options || {};\n    return new RegExp(source, opts.flags || (opts.nocase ? 'i' : ''));\n  } catch (err) {\n    if (options && options.debug === true) throw err;\n    return /$^/;\n  }\n};\n\n/**\n * Picomatch constants.\n * @return {Object}\n */\n\npicomatch.constants = constants;\n\n/**\n * Expose \"picomatch\"\n */\n\nmodule.exports = picomatch;\n","'use strict';\n\nconst utils = require('./utils');\nconst {\n  CHAR_ASTERISK,             /* * */\n  CHAR_AT,                   /* @ */\n  CHAR_BACKWARD_SLASH,       /* \\ */\n  CHAR_COMMA,                /* , */\n  CHAR_DOT,                  /* . */\n  CHAR_EXCLAMATION_MARK,     /* ! */\n  CHAR_FORWARD_SLASH,        /* / */\n  CHAR_LEFT_CURLY_BRACE,     /* { */\n  CHAR_LEFT_PARENTHESES,     /* ( */\n  CHAR_LEFT_SQUARE_BRACKET,  /* [ */\n  CHAR_PLUS,                 /* + */\n  CHAR_QUESTION_MARK,        /* ? */\n  CHAR_RIGHT_CURLY_BRACE,    /* } */\n  CHAR_RIGHT_PARENTHESES,    /* ) */\n  CHAR_RIGHT_SQUARE_BRACKET  /* ] */\n} = require('./constants');\n\nconst isPathSeparator = code => {\n  return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;\n};\n\nconst depth = token => {\n  if (token.isPrefix !== true) {\n    token.depth = token.isGlobstar ? Infinity : 1;\n  }\n};\n\n/**\n * Quickly scans a glob pattern and returns an object with a handful of\n * useful properties, like `isGlob`, `path` (the leading non-glob, if it exists),\n * `glob` (the actual pattern), `negated` (true if the path starts with `!` but not\n * with `!(`) and `negatedExtglob` (true if the path starts with `!(`).\n *\n * ```js\n * const pm = require('picomatch');\n * console.log(pm.scan('foo/bar/*.js'));\n * { isGlob: true, input: 'foo/bar/*.js', base: 'foo/bar', glob: '*.js' }\n * ```\n * @param {String} `str`\n * @param {Object} `options`\n * @return {Object} Returns an object with tokens and regex source string.\n * @api public\n */\n\nconst scan = (input, options) => {\n  const opts = options || {};\n\n  const length = input.length - 1;\n  const scanToEnd = opts.parts === true || opts.scanToEnd === true;\n  const slashes = [];\n  const tokens = [];\n  const parts = [];\n\n  let str = input;\n  let index = -1;\n  let start = 0;\n  let lastIndex = 0;\n  let isBrace = false;\n  let isBracket = false;\n  let isGlob = false;\n  let isExtglob = false;\n  let isGlobstar = false;\n  let braceEscaped = false;\n  let backslashes = false;\n  let negated = false;\n  let negatedExtglob = false;\n  let finished = false;\n  let braces = 0;\n  let prev;\n  let code;\n  let token = { value: '', depth: 0, isGlob: false };\n\n  const eos = () => index >= length;\n  const peek = () => str.charCodeAt(index + 1);\n  const advance = () => {\n    prev = code;\n    return str.charCodeAt(++index);\n  };\n\n  while (index < length) {\n    code = advance();\n    let next;\n\n    if (code === CHAR_BACKWARD_SLASH) {\n      backslashes = token.backslashes = true;\n      code = advance();\n\n      if (code === CHAR_LEFT_CURLY_BRACE) {\n        braceEscaped = true;\n      }\n      continue;\n    }\n\n    if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {\n      braces++;\n\n      while (eos() !== true && (code = advance())) {\n        if (code === CHAR_BACKWARD_SLASH) {\n          backslashes = token.backslashes = true;\n          advance();\n          continue;\n        }\n\n        if (code === CHAR_LEFT_CURLY_BRACE) {\n          braces++;\n          continue;\n        }\n\n        if (braceEscaped !== true && code === CHAR_DOT && (code = advance()) === CHAR_DOT) {\n          isBrace = token.isBrace = true;\n          isGlob = token.isGlob = true;\n          finished = true;\n\n          if (scanToEnd === true) {\n            continue;\n          }\n\n          break;\n        }\n\n        if (braceEscaped !== true && code === CHAR_COMMA) {\n          isBrace = token.isBrace = true;\n          isGlob = token.isGlob = true;\n          finished = true;\n\n          if (scanToEnd === true) {\n            continue;\n          }\n\n          break;\n        }\n\n        if (code === CHAR_RIGHT_CURLY_BRACE) {\n          braces--;\n\n          if (braces === 0) {\n            braceEscaped = false;\n            isBrace = token.isBrace = true;\n            finished = true;\n            break;\n          }\n        }\n      }\n\n      if (scanToEnd === true) {\n        continue;\n      }\n\n      break;\n    }\n\n    if (code === CHAR_FORWARD_SLASH) {\n      slashes.push(index);\n      tokens.push(token);\n      token = { value: '', depth: 0, isGlob: false };\n\n      if (finished === true) continue;\n      if (prev === CHAR_DOT && index === (start + 1)) {\n        start += 2;\n        continue;\n      }\n\n      lastIndex = index + 1;\n      continue;\n    }\n\n    if (opts.noext !== true) {\n      const isExtglobChar = code === CHAR_PLUS\n        || code === CHAR_AT\n        || code === CHAR_ASTERISK\n        || code === CHAR_QUESTION_MARK\n        || code === CHAR_EXCLAMATION_MARK;\n\n      if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES) {\n        isGlob = token.isGlob = true;\n        isExtglob = token.isExtglob = true;\n        finished = true;\n        if (code === CHAR_EXCLAMATION_MARK && index === start) {\n          negatedExtglob = true;\n        }\n\n        if (scanToEnd === true) {\n          while (eos() !== true && (code = advance())) {\n            if (code === CHAR_BACKWARD_SLASH) {\n              backslashes = token.backslashes = true;\n              code = advance();\n              continue;\n            }\n\n            if (code === CHAR_RIGHT_PARENTHESES) {\n              isGlob = token.isGlob = true;\n              finished = true;\n              break;\n            }\n          }\n          continue;\n        }\n        break;\n      }\n    }\n\n    if (code === CHAR_ASTERISK) {\n      if (prev === CHAR_ASTERISK) isGlobstar = token.isGlobstar = true;\n      isGlob = token.isGlob = true;\n      finished = true;\n\n      if (scanToEnd === true) {\n        continue;\n      }\n      break;\n    }\n\n    if (code === CHAR_QUESTION_MARK) {\n      isGlob = token.isGlob = true;\n      finished = true;\n\n      if (scanToEnd === true) {\n        continue;\n      }\n      break;\n    }\n\n    if (code === CHAR_LEFT_SQUARE_BRACKET) {\n      while (eos() !== true && (next = advance())) {\n        if (next === CHAR_BACKWARD_SLASH) {\n          backslashes = token.backslashes = true;\n          advance();\n          continue;\n        }\n\n        if (next === CHAR_RIGHT_SQUARE_BRACKET) {\n          isBracket = token.isBracket = true;\n          isGlob = token.isGlob = true;\n          finished = true;\n          break;\n        }\n      }\n\n      if (scanToEnd === true) {\n        continue;\n      }\n\n      break;\n    }\n\n    if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK && index === start) {\n      negated = token.negated = true;\n      start++;\n      continue;\n    }\n\n    if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES) {\n      isGlob = token.isGlob = true;\n\n      if (scanToEnd === true) {\n        while (eos() !== true && (code = advance())) {\n          if (code === CHAR_LEFT_PARENTHESES) {\n            backslashes = token.backslashes = true;\n            code = advance();\n            continue;\n          }\n\n          if (code === CHAR_RIGHT_PARENTHESES) {\n            finished = true;\n            break;\n          }\n        }\n        continue;\n      }\n      break;\n    }\n\n    if (isGlob === true) {\n      finished = true;\n\n      if (scanToEnd === true) {\n        continue;\n      }\n\n      break;\n    }\n  }\n\n  if (opts.noext === true) {\n    isExtglob = false;\n    isGlob = false;\n  }\n\n  let base = str;\n  let prefix = '';\n  let glob = '';\n\n  if (start > 0) {\n    prefix = str.slice(0, start);\n    str = str.slice(start);\n    lastIndex -= start;\n  }\n\n  if (base && isGlob === true && lastIndex > 0) {\n    base = str.slice(0, lastIndex);\n    glob = str.slice(lastIndex);\n  } else if (isGlob === true) {\n    base = '';\n    glob = str;\n  } else {\n    base = str;\n  }\n\n  if (base && base !== '' && base !== '/' && base !== str) {\n    if (isPathSeparator(base.charCodeAt(base.length - 1))) {\n      base = base.slice(0, -1);\n    }\n  }\n\n  if (opts.unescape === true) {\n    if (glob) glob = utils.removeBackslashes(glob);\n\n    if (base && backslashes === true) {\n      base = utils.removeBackslashes(base);\n    }\n  }\n\n  const state = {\n    prefix,\n    input,\n    start,\n    base,\n    glob,\n    isBrace,\n    isBracket,\n    isGlob,\n    isExtglob,\n    isGlobstar,\n    negated,\n    negatedExtglob\n  };\n\n  if (opts.tokens === true) {\n    state.maxDepth = 0;\n    if (!isPathSeparator(code)) {\n      tokens.push(token);\n    }\n    state.tokens = tokens;\n  }\n\n  if (opts.parts === true || opts.tokens === true) {\n    let prevIndex;\n\n    for (let idx = 0; idx < slashes.length; idx++) {\n      const n = prevIndex ? prevIndex + 1 : start;\n      const i = slashes[idx];\n      const value = input.slice(n, i);\n      if (opts.tokens) {\n        if (idx === 0 && start !== 0) {\n          tokens[idx].isPrefix = true;\n          tokens[idx].value = prefix;\n        } else {\n          tokens[idx].value = value;\n        }\n        depth(tokens[idx]);\n        state.maxDepth += tokens[idx].depth;\n      }\n      if (idx !== 0 || value !== '') {\n        parts.push(value);\n      }\n      prevIndex = i;\n    }\n\n    if (prevIndex && prevIndex + 1 < input.length) {\n      const value = input.slice(prevIndex + 1);\n      parts.push(value);\n\n      if (opts.tokens) {\n        tokens[tokens.length - 1].value = value;\n        depth(tokens[tokens.length - 1]);\n        state.maxDepth += tokens[tokens.length - 1].depth;\n      }\n    }\n\n    state.slashes = slashes;\n    state.parts = parts;\n  }\n\n  return state;\n};\n\nmodule.exports = scan;\n","'use strict';\n\nconst path = require('path');\nconst win32 = process.platform === 'win32';\nconst {\n  REGEX_BACKSLASH,\n  REGEX_REMOVE_BACKSLASH,\n  REGEX_SPECIAL_CHARS,\n  REGEX_SPECIAL_CHARS_GLOBAL\n} = require('./constants');\n\nexports.isObject = val => val !== null && typeof val === 'object' && !Array.isArray(val);\nexports.hasRegexChars = str => REGEX_SPECIAL_CHARS.test(str);\nexports.isRegexChar = str => str.length === 1 && exports.hasRegexChars(str);\nexports.escapeRegex = str => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, '\\\\$1');\nexports.toPosixSlashes = str => str.replace(REGEX_BACKSLASH, '/');\n\nexports.removeBackslashes = str => {\n  return str.replace(REGEX_REMOVE_BACKSLASH, match => {\n    return match === '\\\\' ? '' : match;\n  });\n};\n\nexports.supportsLookbehinds = () => {\n  const segs = process.version.slice(1).split('.').map(Number);\n  if (segs.length === 3 && segs[0] >= 9 || (segs[0] === 8 && segs[1] >= 10)) {\n    return true;\n  }\n  return false;\n};\n\nexports.isWindows = options => {\n  if (options && typeof options.windows === 'boolean') {\n    return options.windows;\n  }\n  return win32 === true || path.sep === '\\\\';\n};\n\nexports.escapeLast = (input, char, lastIdx) => {\n  const idx = input.lastIndexOf(char, lastIdx);\n  if (idx === -1) return input;\n  if (input[idx - 1] === '\\\\') return exports.escapeLast(input, char, idx - 1);\n  return `${input.slice(0, idx)}\\\\${input.slice(idx)}`;\n};\n\nexports.removePrefix = (input, state = {}) => {\n  let output = input;\n  if (output.startsWith('./')) {\n    output = output.slice(2);\n    state.prefix = './';\n  }\n  return output;\n};\n\nexports.wrapOutput = (input, state = {}, options = {}) => {\n  const prepend = options.contains ? '' : '^';\n  const append = options.contains ? '' : '$';\n\n  let output = `${prepend}(?:${input})${append}`;\n  if (state.negated === true) {\n    output = `(?:^(?!${output}).*$)`;\n  }\n  return output;\n};\n","/*!\n * to-regex-range <https://github.com/micromatch/to-regex-range>\n *\n * Copyright (c) 2015-present, Jon Schlinkert.\n * Released under the MIT License.\n */\n\n'use strict';\n\nconst isNumber = require('is-number');\n\nconst toRegexRange = (min, max, options) => {\n  if (isNumber(min) === false) {\n    throw new TypeError('toRegexRange: expected the first argument to be a number');\n  }\n\n  if (max === void 0 || min === max) {\n    return String(min);\n  }\n\n  if (isNumber(max) === false) {\n    throw new TypeError('toRegexRange: expected the second argument to be a number.');\n  }\n\n  let opts = { relaxZeros: true, ...options };\n  if (typeof opts.strictZeros === 'boolean') {\n    opts.relaxZeros = opts.strictZeros === false;\n  }\n\n  let relax = String(opts.relaxZeros);\n  let shorthand = String(opts.shorthand);\n  let capture = String(opts.capture);\n  let wrap = String(opts.wrap);\n  let cacheKey = min + ':' + max + '=' + relax + shorthand + capture + wrap;\n\n  if (toRegexRange.cache.hasOwnProperty(cacheKey)) {\n    return toRegexRange.cache[cacheKey].result;\n  }\n\n  let a = Math.min(min, max);\n  let b = Math.max(min, max);\n\n  if (Math.abs(a - b) === 1) {\n    let result = min + '|' + max;\n    if (opts.capture) {\n      return `(${result})`;\n    }\n    if (opts.wrap === false) {\n      return result;\n    }\n    return `(?:${result})`;\n  }\n\n  let isPadded = hasPadding(min) || hasPadding(max);\n  let state = { min, max, a, b };\n  let positives = [];\n  let negatives = [];\n\n  if (isPadded) {\n    state.isPadded = isPadded;\n    state.maxLen = String(state.max).length;\n  }\n\n  if (a < 0) {\n    let newMin = b < 0 ? Math.abs(b) : 1;\n    negatives = splitToPatterns(newMin, Math.abs(a), state, opts);\n    a = state.a = 0;\n  }\n\n  if (b >= 0) {\n    positives = splitToPatterns(a, b, state, opts);\n  }\n\n  state.negatives = negatives;\n  state.positives = positives;\n  state.result = collatePatterns(negatives, positives, opts);\n\n  if (opts.capture === true) {\n    state.result = `(${state.result})`;\n  } else if (opts.wrap !== false && (positives.length + negatives.length) > 1) {\n    state.result = `(?:${state.result})`;\n  }\n\n  toRegexRange.cache[cacheKey] = state;\n  return state.result;\n};\n\nfunction collatePatterns(neg, pos, options) {\n  let onlyNegative = filterPatterns(neg, pos, '-', false, options) || [];\n  let onlyPositive = filterPatterns(pos, neg, '', false, options) || [];\n  let intersected = filterPatterns(neg, pos, '-?', true, options) || [];\n  let subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);\n  return subpatterns.join('|');\n}\n\nfunction splitToRanges(min, max) {\n  let nines = 1;\n  let zeros = 1;\n\n  let stop = countNines(min, nines);\n  let stops = new Set([max]);\n\n  while (min <= stop && stop <= max) {\n    stops.add(stop);\n    nines += 1;\n    stop = countNines(min, nines);\n  }\n\n  stop = countZeros(max + 1, zeros) - 1;\n\n  while (min < stop && stop <= max) {\n    stops.add(stop);\n    zeros += 1;\n    stop = countZeros(max + 1, zeros) - 1;\n  }\n\n  stops = [...stops];\n  stops.sort(compare);\n  return stops;\n}\n\n/**\n * Convert a range to a regex pattern\n * @param {Number} `start`\n * @param {Number} `stop`\n * @return {String}\n */\n\nfunction rangeToPattern(start, stop, options) {\n  if (start === stop) {\n    return { pattern: start, count: [], digits: 0 };\n  }\n\n  let zipped = zip(start, stop);\n  let digits = zipped.length;\n  let pattern = '';\n  let count = 0;\n\n  for (let i = 0; i < digits; i++) {\n    let [startDigit, stopDigit] = zipped[i];\n\n    if (startDigit === stopDigit) {\n      pattern += startDigit;\n\n    } else if (startDigit !== '0' || stopDigit !== '9') {\n      pattern += toCharacterClass(startDigit, stopDigit, options);\n\n    } else {\n      count++;\n    }\n  }\n\n  if (count) {\n    pattern += options.shorthand === true ? '\\\\d' : '[0-9]';\n  }\n\n  return { pattern, count: [count], digits };\n}\n\nfunction splitToPatterns(min, max, tok, options) {\n  let ranges = splitToRanges(min, max);\n  let tokens = [];\n  let start = min;\n  let prev;\n\n  for (let i = 0; i < ranges.length; i++) {\n    let max = ranges[i];\n    let obj = rangeToPattern(String(start), String(max), options);\n    let zeros = '';\n\n    if (!tok.isPadded && prev && prev.pattern === obj.pattern) {\n      if (prev.count.length > 1) {\n        prev.count.pop();\n      }\n\n      prev.count.push(obj.count[0]);\n      prev.string = prev.pattern + toQuantifier(prev.count);\n      start = max + 1;\n      continue;\n    }\n\n    if (tok.isPadded) {\n      zeros = padZeros(max, tok, options);\n    }\n\n    obj.string = zeros + obj.pattern + toQuantifier(obj.count);\n    tokens.push(obj);\n    start = max + 1;\n    prev = obj;\n  }\n\n  return tokens;\n}\n\nfunction filterPatterns(arr, comparison, prefix, intersection, options) {\n  let result = [];\n\n  for (let ele of arr) {\n    let { string } = ele;\n\n    // only push if _both_ are negative...\n    if (!intersection && !contains(comparison, 'string', string)) {\n      result.push(prefix + string);\n    }\n\n    // or _both_ are positive\n    if (intersection && contains(comparison, 'string', string)) {\n      result.push(prefix + string);\n    }\n  }\n  return result;\n}\n\n/**\n * Zip strings\n */\n\nfunction zip(a, b) {\n  let arr = [];\n  for (let i = 0; i < a.length; i++) arr.push([a[i], b[i]]);\n  return arr;\n}\n\nfunction compare(a, b) {\n  return a > b ? 1 : b > a ? -1 : 0;\n}\n\nfunction contains(arr, key, val) {\n  return arr.some(ele => ele[key] === val);\n}\n\nfunction countNines(min, len) {\n  return Number(String(min).slice(0, -len) + '9'.repeat(len));\n}\n\nfunction countZeros(integer, zeros) {\n  return integer - (integer % Math.pow(10, zeros));\n}\n\nfunction toQuantifier(digits) {\n  let [start = 0, stop = ''] = digits;\n  if (stop || start > 1) {\n    return `{${start + (stop ? ',' + stop : '')}}`;\n  }\n  return '';\n}\n\nfunction toCharacterClass(a, b, options) {\n  return `[${a}${(b - a === 1) ? '' : '-'}${b}]`;\n}\n\nfunction hasPadding(str) {\n  return /^-?(0+)\\d/.test(str);\n}\n\nfunction padZeros(value, tok, options) {\n  if (!tok.isPadded) {\n    return value;\n  }\n\n  let diff = Math.abs(tok.maxLen - String(value).length);\n  let relax = options.relaxZeros !== false;\n\n  switch (diff) {\n    case 0:\n      return '';\n    case 1:\n      return relax ? '0?' : '0';\n    case 2:\n      return relax ? '0{0,2}' : '00';\n    default: {\n      return relax ? `0{0,${diff}}` : `0{${diff}}`;\n    }\n  }\n}\n\n/**\n * Cache\n */\n\ntoRegexRange.cache = {};\ntoRegexRange.clearCache = () => (toRegexRange.cache = {});\n\n/**\n * Expose `toRegexRange`\n */\n\nmodule.exports = toRegexRange;\n","import * as fs from 'fs';\r\nimport micromatch from 'micromatch';\r\nimport * as path from 'path';\r\nimport * as vscode from 'vscode';\r\n\r\ninterface ConfigurationItem {\r\n    name: string;\r\n    directoryPath: string;\r\n    allowedDirectories: string[];\r\n    excludedDirectories: string[];\r\n    excludedFiles: string[];\r\n    extensions: string[];\r\n    showAllExtensions: boolean; // Nueva propiedad para indicar si se deben mostrar todas las combinaciones de extensiones\r\n}\r\n\r\nexport class SummaryViewProvider implements vscode.WebviewViewProvider {\r\n    public static readonly viewType = 'summaryConfigView';\r\n\r\n    constructor(private readonly _extensionUri: vscode.Uri) { }\r\n\r\n    public resolveWebviewView(\r\n        webviewView: vscode.WebviewView,\r\n        context: vscode.WebviewViewResolveContext,\r\n        _token: vscode.CancellationToken\r\n    ) {\r\n        webviewView.webview.options = { enableScripts: true };\r\n        webviewView.webview.html = this.getWebviewContent(webviewView.webview);\r\n\r\n        webviewView.webview.onDidReceiveMessage(\r\n            async (message) => {\r\n                switch (message.command) {\r\n                    case 'saveConfig':\r\n                        try {\r\n                            const savedConfigName = await this.saveConfiguration(message);\r\n                            await this.sendConfigsToWebview(webviewView.webview);\r\n                            webviewView.webview.postMessage({ command: 'configSaved', configName: savedConfigName });\r\n                        } catch (error) {\r\n                            console.error('Error saving configuration:', error);\r\n                        }\r\n                        break;\r\n                    case 'runSummary':\r\n                        if (message.configName) {\r\n                            await this.runSummary(message.configName);\r\n                        } else {\r\n                            vscode.window.showErrorMessage('No configuration selected.');\r\n                        }\r\n                        break;\r\n                    case 'getConfigs':\r\n                        await this.sendConfigsToWebview(webviewView.webview);\r\n                        break;\r\n                    case 'deleteConfig':\r\n                        if (message.configName) {\r\n                            await this.deleteConfiguration(message.configName);\r\n                            await this.sendConfigsToWebview(webviewView.webview);\r\n                        } else {\r\n                            vscode.window.showErrorMessage('No configuration selected for deletion.');\r\n                        }\r\n                        break;\r\n                    case 'findExtensions':\r\n                        try {\r\n                            const extensions = await this.findExtensions(\r\n                                message.directoryPath,\r\n                                message.allowedDirectories.split(',').map((dir: string) => dir.trim()),\r\n                                message.excludedDirectories.split(',').map((dir: string) => dir.trim()),\r\n                                message.excludedFiles.split(',').map((file: string) => file.trim()),\r\n                                message.showAllExtensions // Enviar preferencia para mostrar todas las combinaciones de extensiones\r\n                            );\r\n                            webviewView.webview.postMessage({\r\n                                command: 'setExtensions',\r\n                                extensions: Array.from(extensions)\r\n                            });\r\n                        } catch (error) {\r\n                            console.error('Error finding extensions:', error);\r\n                            webviewView.webview.postMessage({\r\n                                command: 'setExtensions',\r\n                                extensions: []\r\n                            });\r\n                        }\r\n                        break;\r\n                }\r\n            }\r\n        );\r\n\r\n        this.sendConfigsToWebview(webviewView.webview);\r\n    }\r\n\r\n    private async findExtensions(directoryPath: string, allowedDirectories: string[], excludedDirectories: string[], excludedFiles: string[], showAllExtensions: boolean): Promise<Set<string>> {\r\n        const extensions = new Set<string>();\r\n\r\n        const isExcluded = (relativePath: string) => {\r\n            const normalizedPath = this.normalizePath(relativePath);\r\n            return micromatch.isMatch(normalizedPath, excludedDirectories.map(this.normalizePath)) || \r\n                   micromatch.isMatch(path.basename(normalizedPath), excludedFiles);\r\n        };\r\n\r\n        const processDirectory = (dir: string, basePath: string) => {\r\n            const files = fs.readdirSync(dir);\r\n            for (const file of files) {\r\n                const fullPath = path.join(dir, file);\r\n                const relativePath = path.relative(basePath, fullPath);\r\n\r\n                if (isExcluded(relativePath)) {\r\n                    continue;\r\n                }\r\n\r\n                if (fs.statSync(fullPath).isDirectory()) {\r\n                    processDirectory(fullPath, basePath); // Recursively process subdirectories\r\n                } else {\r\n                    const parts = file.split('.');\r\n                    if (parts.length > 1) {\r\n                        if (showAllExtensions) {\r\n                            for (let i = 1; i < parts.length; i++) {\r\n                                const ext = '.' + parts.slice(i).join('.').toLowerCase();\r\n                                extensions.add(ext);\r\n                            }\r\n                        } else {\r\n                            const ext = '.' + parts[parts.length - 1].toLowerCase();\r\n                            extensions.add(ext);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        };\r\n\r\n        if (allowedDirectories.length > 0) {\r\n            for (const allowedDir of allowedDirectories) {\r\n                const fullAllowedPath = path.join(directoryPath, allowedDir);\r\n                if (fs.existsSync(fullAllowedPath)) {\r\n                    processDirectory(fullAllowedPath, directoryPath);\r\n                }\r\n            }\r\n        } else {\r\n            processDirectory(directoryPath, directoryPath);\r\n        }\r\n\r\n        return extensions;\r\n    }\r\n\r\n    public async runSummary(configName: string) {\r\n        const config = vscode.workspace.getConfiguration('summary1');\r\n        const configurations = config.get('configurations') as ConfigurationItem[];\r\n        const selectedConfig = configurations.find(c => c.name === configName);\r\n\r\n        if (!selectedConfig) {\r\n            vscode.window.showErrorMessage('Configuración seleccionada no encontrada.');\r\n            return;\r\n        }\r\n\r\n        const { directoryPath, allowedDirectories, excludedDirectories, excludedFiles, extensions, showAllExtensions } = selectedConfig;\r\n\r\n        if (!directoryPath || extensions.length === 0) {\r\n            vscode.window.showErrorMessage('Por favor, configure todos los ajustes antes de generar el resumen.');\r\n            return;\r\n        }\r\n\r\n        try {\r\n            const summaryContent = await this.generateSummary(directoryPath, allowedDirectories, excludedDirectories, excludedFiles, extensions);\r\n\r\n            if (summaryContent.trim() === '') {\r\n                vscode.window.showErrorMessage('No se encontró contenido para el resumen. Verifique las extensiones y directorios seleccionados.');\r\n                return;\r\n            }\r\n\r\n            const summaryPath = path.join(directoryPath, 'RESUMEN.TXT');\r\n            fs.writeFileSync(summaryPath, summaryContent);\r\n\r\n            vscode.window.showInformationMessage(`Resumen completado con éxito! Guardado en ${summaryPath}`);\r\n        } catch (error) {\r\n            vscode.window.showErrorMessage(`Error al generar el resumen: ${error}`);\r\n        }\r\n    }\r\n\r\n    private async generateSummary(directoryPath: string, allowedDirectories: string[], excludedDirectories: string[], excludedFiles: string[], extensions: string[]): Promise<string> {\r\n        let summaryContent = '';\r\n\r\n        const isExcluded = (relativePath: string) => {\r\n            const normalizedPath = this.normalizePath(relativePath);\r\n            return micromatch.isMatch(normalizedPath, excludedDirectories.map(this.normalizePath)) || \r\n                   micromatch.isMatch(path.basename(normalizedPath), excludedFiles);\r\n        };\r\n\r\n        const processDirectory = (dir: string, basePath: string) => {\r\n            const files = fs.readdirSync(dir);\r\n            for (const file of files) {\r\n                const fullPath = path.join(dir, file);\r\n                const relativePath = path.relative(basePath, fullPath);\r\n\r\n                if (isExcluded(relativePath)) {\r\n                    continue;\r\n                }\r\n\r\n                if (fs.statSync(fullPath).isDirectory()) {\r\n                    processDirectory(fullPath, basePath); // Recursively process subdirectories\r\n                } else {\r\n                    const parts = file.split('.');\r\n                    if (parts.length > 1) {\r\n                        for (let i = 1; i < parts.length; i++) {\r\n                            const ext = '.' + parts.slice(i).join('.').toLowerCase();\r\n                            if (extensions.includes(ext)) {\r\n                                const content = fs.readFileSync(fullPath, 'utf8');\r\n                                summaryContent += `\\n/* Inicio ${relativePath} */\\n${content}\\n/* Fin ${relativePath} */\\n`;\r\n                                break; // Stop after the first matching extension\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        };\r\n\r\n        if (allowedDirectories.length > 0) {\r\n            for (const allowedDir of allowedDirectories) {\r\n                const fullAllowedPath = path.join(directoryPath, allowedDir);\r\n                if (fs.existsSync(fullAllowedPath)) {\r\n                    processDirectory(fullAllowedPath, directoryPath);\r\n                }\r\n            }\r\n        } else {\r\n            processDirectory(directoryPath, directoryPath);\r\n        }\r\n\r\n        return summaryContent;\r\n    }\r\n\r\n    private normalizePath(inputPath: string): string {\r\n        let normalized = inputPath.replace(/\\\\/g, '/');\r\n        normalized = normalized.replace(/([^:])\\/+/g, '$1/');\r\n        return normalized;\r\n    }\r\n\r\n    private async sendConfigsToWebview(webview: vscode.Webview) {\r\n        const config = vscode.workspace.getConfiguration('summary1');\r\n        const configurations = config.get('configurations') as ConfigurationItem[];\r\n    \r\n        webview.postMessage({\r\n            command: 'setConfigs',\r\n            configurations: configurations.map(c => ({\r\n                ...c,\r\n                allowedDirectories: c.allowedDirectories.join(', '),\r\n                excludedDirectories: c.excludedDirectories.join(', '),\r\n                excludedFiles: c.excludedFiles.join(', '),\r\n                showAllExtensions: c.showAllExtensions !== undefined ? c.showAllExtensions : false // Establecer un valor por defecto si no está presente\r\n            }))\r\n        });\r\n    }   \r\n\r\n    private async saveConfiguration(message: any): Promise<string> {\r\n        try {\r\n            const config = vscode.workspace.getConfiguration('summary1');\r\n            let configurations = config.get('configurations') as ConfigurationItem[];\r\n\r\n            const newConfig: ConfigurationItem = {\r\n                name: message.name,\r\n                directoryPath: message.directoryPath,\r\n                allowedDirectories: message.allowedDirectories.split(',').map((dir: string) => dir.trim()),\r\n                excludedDirectories: message.excludedDirectories.split(',').map((dir: string) => dir.trim()),\r\n                excludedFiles: message.excludedFiles.split(',').map((file: string) => file.trim()),\r\n                extensions: message.extensions,\r\n                showAllExtensions: message.showAllExtensions // Guardar la preferencia de mostrar todas las extensiones\r\n            };\r\n\r\n            const existingIndex = configurations.findIndex(c => c.name === newConfig.name);\r\n            if (existingIndex !== -1) {\r\n                configurations[existingIndex] = newConfig;\r\n            } else {\r\n                configurations.push(newConfig);\r\n            }\r\n\r\n            await config.update('configurations', configurations, vscode.ConfigurationTarget.Global);\r\n            vscode.window.showInformationMessage('Configuración guardada correctamente');\r\n            return newConfig.name;\r\n        } catch (error) {\r\n            vscode.window.showErrorMessage(`Error al guardar la configuración: ${error}`);\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    private async deleteConfiguration(configName: string) {\r\n        try {\r\n            const config = vscode.workspace.getConfiguration('summary1');\r\n            let configurations = config.get('configurations') as ConfigurationItem[];\r\n            configurations = configurations.filter(c => c.name !== configName);\r\n            await config.update('configurations', configurations, vscode.ConfigurationTarget.Global);\r\n            vscode.window.showInformationMessage('Configuración eliminada exitosamente');\r\n        } catch (error) {\r\n            vscode.window.showErrorMessage(`Error al eliminar la configuración: ${error}`);\r\n        }\r\n    }\r\n\r\n    private getWebviewContent(webview: vscode.Webview) {\r\n        return `\r\n            <!DOCTYPE html>\r\n            <html lang=\"es\">\r\n            <head>\r\n                <meta charset=\"UTF-8\">\r\n                <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n                <title>Configuración de eDev Summary</title>\r\n                <style>\r\n                    :root {\r\n                        --background: #1e1e1e;\r\n                        --foreground: #e0e0e0;\r\n                        --primary: #2c2c2c;\r\n                        --secondary: #383838;\r\n                        --highlight: #2d8ce2; \r\n                        --badge-default: #6a6a6a; \r\n                        --accent: #6a6a6a;\r\n                        --error: #b85c5c;\r\n                        --success: #4caf50;\r\n                        --toggle-off: #888;\r\n                        --toggle-on: #4caf50;\r\n                    }\r\n                    body { \r\n                        padding: 10px; \r\n                        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;\r\n                        background-color: var(--background);\r\n                        color: var(--foreground);\r\n                        line-height: 1.4;\r\n                        margin: 0;\r\n                    }\r\n                    .container {\r\n                        max-width: 500px;\r\n                        background-color: var(--primary);\r\n                        border-radius: 6px;\r\n                        padding: 15px;\r\n                        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);\r\n                    }\r\n                    h1 { \r\n                        color: var(--foreground);\r\n                        margin-bottom: 15px;\r\n                        text-align: center;\r\n                        font-size: 18px;\r\n                    }\r\n                    label { \r\n                        display: block; \r\n                        margin-top: 8px;\r\n                        font-weight: bold;\r\n                        color: var(--foreground);\r\n                    }\r\n                    input, select { \r\n                        width: 100%; \r\n                        padding: 6px; \r\n                        margin-top: 4px;\r\n                        margin-bottom: 12px; \r\n                        border: 1px solid var(--highlight);\r\n                        border-radius: 3px;\r\n                        background-color: var(--secondary);\r\n                        color: var(--foreground);\r\n                        font-size: 13px;\r\n                        box-sizing: border-box;\r\n                    }\r\n                    input:focus, select:focus {\r\n                        outline: none;\r\n                        border-color: var(--highlight);\r\n                        box-shadow: 0 0 0 2px rgba(45, 140, 226, 0.5);\r\n                    }\r\n                    .extension-badges {\r\n                        display: flex;\r\n                        flex-wrap: wrap;\r\n                        gap: 6px;\r\n                        margin-top: 8px;\r\n                    }\r\n                    .extension-badge {\r\n                        background-color: var(--badge-default); \r\n                        color: var(--foreground);\r\n                        padding: 5px 10px;\r\n                        border-radius: 12px;\r\n                        font-size: 12px;\r\n                        display: flex;\r\n                        align-items: center;\r\n                        user-select: none;\r\n                        cursor: pointer;\r\n                        transition: background-color 0.2s ease;\r\n                    }\r\n                    .extension-badge.selected {\r\n                        background-color: var(--highlight); \r\n                    }\r\n                    .extension-badge.disabled {\r\n                        opacity: 0.5;\r\n                        cursor: not-allowed;\r\n                    }\r\n                    .button-group {\r\n                        display: flex;\r\n                        gap: 10px;\r\n                        margin-top: 15px;\r\n                    }\r\n                    button {\r\n                        flex: 1;\r\n                        padding: 10px;\r\n                        border: none;\r\n                        border-radius: 3px;\r\n                        cursor: pointer;\r\n                        font-weight: bold;\r\n                        transition: background-color 0.2s ease;\r\n                        font-size: 13px;\r\n                        background-color: var(--highlight);\r\n                        color: white;\r\n                    }\r\n                    button:hover {\r\n                        background-color: #1b6fb2;\r\n                    }\r\n                    .loader-container {\r\n                        display: flex;\r\n                        justify-content: center;\r\n                        align-items: center;\r\n                        height: 40px;\r\n                    }\r\n                    .loader {\r\n                        border: 3px solid var(--primary);\r\n                        border-top: 3px solid var(--highlight);\r\n                        border-radius: 50%;\r\n                        width: 20px;\r\n                        height: 20px;\r\n                        animation: spin 1s linear infinite;\r\n                    }\r\n                    #loaderText {\r\n                        margin-left: 10px;\r\n                        color: var(--foreground);\r\n                        font-size: 13px;\r\n                    }\r\n                    @keyframes spin {\r\n                        0% { transform: rotate(0deg); }\r\n                        100% { transform: rotate(360deg); }\r\n                    }\r\n                    /* Estilo para el toggle switch */\r\n                    .toggle-container {\r\n                        display: flex;\r\n                        align-items: center;\r\n                        margin-top: 8px;\r\n                        margin-bottom: 12px;\r\n                    }\r\n                    .toggle-switch {\r\n                        position: relative;\r\n                        display: inline-block;\r\n                        width: 40px;\r\n                        height: 20px;\r\n                        margin-right: 10px;\r\n                    }\r\n                    .toggle-switch input {\r\n                        opacity: 0;\r\n                        width: 0;\r\n                        height: 0;\r\n                    }\r\n                    .slider {\r\n                        position: absolute;\r\n                        cursor: pointer;\r\n                        top: 0;\r\n                        left: 0;\r\n                        right: 0;\r\n                        bottom: 0;\r\n                        background-color: var(--toggle-off);\r\n                        transition: .4s;\r\n                        border-radius: 34px;\r\n                    }\r\n                    .slider:before {\r\n                        position: absolute;\r\n                        content: \"\";\r\n                        height: 14px;\r\n                        width: 14px;\r\n                        left: 3px;\r\n                        bottom: 3px;\r\n                        background-color: white;\r\n                        transition: .4s;\r\n                        border-radius: 50%;\r\n                    }\r\n                    input:checked + .slider {\r\n                        background-color: var(--toggle-on);\r\n                    }\r\n                    input:checked + .slider:before {\r\n                        transform: translateX(20px);\r\n                    }\r\n                </style>\r\n            </head>\r\n            <body>\r\n                <div class=\"container\">\r\n                    <h1>Configurar Extensión</h1>\r\n                    <select id=\"configSelector\">\r\n                        <option value=\"\">Crear nueva configuración</option>\r\n                    </select>\r\n                    <form id=\"config-form\">\r\n                        <label for=\"configName\">Nombre de la Configuración:</label>\r\n                        <input type=\"text\" id=\"configName\" required placeholder=\"Ingrese el nombre de la configuración\">\r\n\r\n                        <label for=\"directoryPath\">Ruta del Directorio:</label>\r\n                        <div class=\"example\">Ejemplo: C:/Proyectos/MiProyecto</div>\r\n                        <input type=\"text\" id=\"directoryPath\" required placeholder=\"Ingrese la ruta del directorio base\">\r\n                        \r\n                        <label for=\"allowedDirectories\">Directorios Permitidos:</label>\r\n                        <div class=\"example\">Ejemplo: src/app, src/componentes</div>\r\n                        <input type=\"text\" id=\"allowedDirectories\" placeholder=\"Ingrese los directorios permitidos (separados por comas)\">\r\n                        \r\n                        <label for=\"excludedDirectories\">Directorios Excluidos:</label>\r\n                        <div class=\"example\">Ejemplo: node_modules, dist</div>\r\n                        <input type=\"text\" id=\"excludedDirectories\" placeholder=\"Ingrese los directorios excluidos (separados por comas)\">\r\n                        \r\n                        <label for=\"excludedFiles\">Archivos Excluidos:</label>\r\n                        <div class=\"example\">Ejemplo: package-lock.json, .gitignore</div>\r\n                        <input type=\"text\" id=\"excludedFiles\" placeholder=\"Ingrese los archivos excluidos (separados por comas)\">\r\n\r\n                        <div class=\"toggle-container\">\r\n                            <label for=\"showAllExtensionsCheckbox\">Mostrar todas las combinaciones de extensiones:</label>\r\n                            <label class=\"toggle-switch\">\r\n                                <input type=\"checkbox\" id=\"showAllExtensionsCheckbox\">\r\n                                <span class=\"slider\"></span>\r\n                            </label>\r\n                        </div>\r\n                        \r\n                        <label for=\"extensions\">Extensiones de Archivo:</label>\r\n                        <div class=\"loader-container\" id=\"loaderContainer\" style=\"display: none;\">\r\n                            <div class=\"loader\"></div>\r\n                            <div id=\"loaderText\" style=\"margin-left: 10px;\">Cargando extensiones...</div>\r\n                        </div>\r\n                        <div id=\"extensionBadges\" class=\"extension-badges\"></div>\r\n                        \r\n                        <div class=\"button-group\">\r\n                            <button type=\"submit\">Guardar</button>\r\n                            <button id=\"runSummary\" type=\"button\">Generar</button>\r\n                            <button id=\"deleteConfig\" type=\"button\">Eliminar</button>\r\n                        </div>\r\n                    </form>\r\n                </div>\r\n                <script>\r\n                    const vscode = acquireVsCodeApi();\r\n                    const configSelector = document.getElementById('configSelector');\r\n                    const configNameInput = document.getElementById('configName');\r\n                    const directoryPathInput = document.getElementById('directoryPath');\r\n                    const allowedDirectoriesInput = document.getElementById('allowedDirectories');\r\n                    const excludedDirectoriesInput = document.getElementById('excludedDirectories');\r\n                    const excludedFilesInput = document.getElementById('excludedFiles');\r\n                    const showAllExtensionsCheckbox = document.getElementById('showAllExtensionsCheckbox');\r\n                    const extensionBadgesDiv = document.getElementById('extensionBadges');\r\n                    const runSummaryButton = document.getElementById('runSummary');\r\n                    const deleteConfigButton = document.getElementById('deleteConfig');\r\n\r\n                    let configurations = [];\r\n                    let selectedExtensions = new Set();\r\n\r\n                    // Valores por defecto\r\n                    const defaultExcludedDirectories = [\r\n                            'node_modules',\r\n                            '.git',\r\n                            'dist',\r\n                            'build',\r\n                            'out',\r\n                            'target',\r\n                            '.idea',\r\n                            '.vscode',\r\n                            '.gradle',\r\n                            'bin',\r\n                            'obj',\r\n                            'logs',\r\n                            'temp',\r\n                            'tmp',\r\n                            'cache',\r\n                            'coverage',\r\n                            '__pycache__',\r\n                            'venv',\r\n                            'env',\r\n                            '.next',\r\n                            '.nuxt',\r\n                            'vendor'\r\n                        ].join(', ');\r\n                        const defaultExcludedFiles = [\r\n                            'package-lock.json',\r\n                            '.gitignore',\r\n                            '.DS_Store',\r\n                            'Thumbs.db',\r\n                            '*.log',\r\n                            '*.tmp',\r\n                            '*.temp',\r\n                            '*.swp',\r\n                            '*.bak',\r\n                            '*.class',\r\n                            '*.pyc',\r\n                            '*.pyo',\r\n                            '*.exe',\r\n                            '*.dll',\r\n                            '*.obj',\r\n                            '*.o',\r\n                            '*.a',\r\n                            '*.lib',\r\n                            '*.so',\r\n                            '*.dylib',\r\n                            '*.ncb',\r\n                            '*.sdf',\r\n                            '*.suo',\r\n                            '*.pdb',\r\n                            '*.idb',\r\n                            '.env',\r\n                            '.env.local',\r\n                            '.env.development.local',\r\n                            '.env.test.local',\r\n                            '.env.production.local',\r\n                            'npm-debug.log*',\r\n                            'yarn-debug.log*',\r\n                            'yarn-error.log*',\r\n                            '.pnp.*',\r\n                            '*.sqlite'\r\n                        ].join(', ');\r\n\r\n                    // Función para inicializar la interfaz\r\n                    function initializeInterface() {\r\n                        configNameInput.value = '';\r\n                        directoryPathInput.value = '';\r\n                        allowedDirectoriesInput.value = '';\r\n                        excludedDirectoriesInput.value = defaultExcludedDirectories;\r\n                        excludedFilesInput.value = defaultExcludedFiles;\r\n                        selectedExtensions.clear();\r\n                        extensionBadgesDiv.innerHTML = '';\r\n                        runSummaryButton.disabled = true;\r\n                        deleteConfigButton.disabled = true;\r\n                        showAllExtensionsCheckbox.checked = false;\r\n                    }\r\n\r\n                    // Inicializar la interfaz al cargar\r\n                    initializeInterface();\r\n\r\n                    vscode.postMessage({ command: 'getConfigs' });\r\n\r\n                    function updateExtensionBadges(extensions) {\r\n                        extensionBadgesDiv.innerHTML = '';\r\n                        extensions.forEach(ext => {\r\n                            const badge = document.createElement('div');\r\n                            badge.className = 'extension-badge' + (selectedExtensions.has(ext) ? ' selected' : '');\r\n                            badge.textContent = ext;\r\n                            badge.classList.add('disabled');\r\n                            extensionBadgesDiv.appendChild(badge);\r\n                        });\r\n                        disableBadges();\r\n                    }\r\n\r\n                    function toggleExtension(ext, badge) {\r\n                        if (!badge.classList.contains('disabled')) {\r\n                            if (selectedExtensions.has(ext)) {\r\n                                selectedExtensions.delete(ext);\r\n                                badge.classList.remove('selected');\r\n                            } else {\r\n                                selectedExtensions.add(ext);\r\n                                badge.classList.add('selected');\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    function disableBadges() {\r\n                        const badges = extensionBadgesDiv.querySelectorAll('.extension-badge');\r\n                        badges.forEach(badge => {\r\n                            badge.classList.add('disabled');\r\n                            badge.onclick = null;\r\n                        });\r\n                    }\r\n\r\n                    function enableBadges() {\r\n                        const badges = extensionBadgesDiv.querySelectorAll('.extension-badge');\r\n                        badges.forEach(badge => {\r\n                            badge.classList.remove('disabled');\r\n                            badge.onclick = () => toggleExtension(badge.textContent, badge);\r\n                        });\r\n                    }\r\n\r\n                    function findExtensions() {\r\n                        const directoryPath = directoryPathInput.value;\r\n                        const allowedDirectories = allowedDirectoriesInput.value;\r\n                        const excludedDirectories = excludedDirectoriesInput.value;\r\n                        const excludedFiles = excludedFilesInput.value;\r\n                        const showAllExtensions = showAllExtensionsCheckbox.checked;\r\n\r\n                        if (directoryPath) {\r\n                            const loaderContainer = document.getElementById('loaderContainer');\r\n                            const loaderText = document.getElementById('loaderText');\r\n                            loaderContainer.style.display = 'flex';\r\n                            loaderText.textContent = 'Cargando extensiones...';\r\n                            disableBadges();\r\n                            const startTime = Date.now();\r\n                            \r\n                            vscode.postMessage({\r\n                                command: 'findExtensions',\r\n                                directoryPath,\r\n                                allowedDirectories,\r\n                                excludedDirectories,\r\n                                excludedFiles,\r\n                                showAllExtensions\r\n                            });\r\n\r\n                            window.extensionsReceived = () => {\r\n                                const elapsedTime = Date.now() - startTime;\r\n                                if (elapsedTime < 1000) {\r\n                                    setTimeout(() => {\r\n                                        loaderContainer.style.display = 'none';\r\n                                        enableBadges();\r\n                                    }, 1000 - elapsedTime);\r\n                                } else {\r\n                                    loaderContainer.style.display = 'none';\r\n                                    enableBadges();\r\n                                }\r\n                            };\r\n                        }\r\n                    }\r\n\r\n                    window.addEventListener('message', event => {\r\n                        const message = event.data;\r\n                        switch (message.command) {\r\n                            case 'setConfigs':\r\n                                configurations = message.configurations;\r\n                                updateConfigSelector();\r\n                                break;\r\n                            case 'setExtensions':\r\n                                updateExtensionBadges(message.extensions);\r\n                                document.getElementById('loaderText').textContent = 'Actualizando extensiones...';\r\n                                if (window.extensionsReceived) {\r\n                                    window.extensionsReceived();\r\n                                }\r\n                                break;\r\n                            case 'configSaved':\r\n                                configSelector.value = message.configName;\r\n                                break;\r\n                        }\r\n                    });\r\n\r\n                    function updateConfigSelector() {\r\n                        configSelector.innerHTML = '<option value=\"\">Crear nueva configuración</option>';\r\n                        configurations.forEach(config => {\r\n                            const option = document.createElement('option');\r\n                            option.value = config.name;\r\n                            option.textContent = config.name;\r\n                            configSelector.appendChild(option);\r\n                        });\r\n                    }\r\n\r\n                    configSelector.addEventListener('change', (event) => {\r\n                        const selectedConfig = configurations.find(c => c.name === event.target.value);\r\n                        if (selectedConfig) {\r\n                            configNameInput.value = selectedConfig.name;\r\n                            directoryPathInput.value = selectedConfig.directoryPath;\r\n                            allowedDirectoriesInput.value = selectedConfig.allowedDirectories;\r\n                            excludedDirectoriesInput.value = selectedConfig.excludedDirectories || defaultExcludedDirectories;\r\n                            excludedFilesInput.value = selectedConfig.excludedFiles || defaultExcludedFiles;\r\n                            selectedExtensions = new Set(selectedConfig.extensions.map(ext => ext.toLowerCase()));\r\n                            showAllExtensionsCheckbox.checked = selectedConfig.showAllExtensions !== undefined ? selectedConfig.showAllExtensions : false; // Manejar el valor por defecto\r\n                            updateExtensionBadges(selectedConfig.extensions);\r\n                            runSummaryButton.disabled = false;\r\n                            deleteConfigButton.disabled = false;\r\n                            findExtensions();\r\n                        } else {\r\n                            initializeInterface();\r\n                        }\r\n                    });\r\n\r\n\r\n                    [directoryPathInput, allowedDirectoriesInput, excludedDirectoriesInput, excludedFilesInput, showAllExtensionsCheckbox].forEach(input => {\r\n                        input.addEventListener('change', findExtensions);\r\n                    });\r\n\r\n                    document.getElementById('config-form').addEventListener('submit', (event) => {\r\n                        event.preventDefault();\r\n                        vscode.postMessage({\r\n                            command: 'saveConfig',\r\n                            name: configNameInput.value,\r\n                            directoryPath: directoryPathInput.value,\r\n                            allowedDirectories: allowedDirectoriesInput.value,\r\n                            excludedDirectories: excludedDirectoriesInput.value,\r\n                            excludedFiles: excludedFilesInput.value,\r\n                            extensions: Array.from(selectedExtensions),\r\n                            showAllExtensions: showAllExtensionsCheckbox.checked\r\n                        });\r\n                    });\r\n\r\n                    runSummaryButton.addEventListener('click', () => {\r\n                        const selectedConfigName = configSelector.value;\r\n                        if (selectedConfigName) {\r\n                            vscode.postMessage({ \r\n                                command: 'runSummary',\r\n                                configName: selectedConfigName\r\n                            });\r\n                        } else {\r\n                            vscode.window.showErrorMessage('Por favor, selecciona una configuración antes de generar el resumen.');\r\n                        }\r\n                    });\r\n\r\n                    deleteConfigButton.addEventListener('click', () => {\r\n                        if (configSelector.value) {\r\n                            vscode.postMessage({ \r\n                                command: 'deleteConfig',\r\n                                configName: configSelector.value\r\n                            });\r\n                        }\r\n                    });\r\n                    vscode.postMessage({ command: 'getConfigs' });\r\n                </script>\r\n            </body>\r\n            </html>\r\n\r\n        `;\r\n    }\r\n}\r\n","\nimport * as vscode from 'vscode';\nimport { SummaryViewProvider } from './SummaryViewProvider';\n\nexport function activate(context: vscode.ExtensionContext) {\n    console.log('Activating extension');\n    const provider = new SummaryViewProvider(context.extensionUri);\n    console.log('Provider created');\n\n    context.subscriptions.push(\n        vscode.window.registerWebviewViewProvider(SummaryViewProvider.viewType, provider)\n    );\n    console.log('Provider registered');\n\n    let disposable = vscode.commands.registerCommand('summary1.runSummary', async () => {\n        const config = vscode.workspace.getConfiguration('summary1');\n        const configurations = config.get('configurations') as Array<{ name: string }>;\n\n        if (configurations.length === 0) {\n            vscode.window.showErrorMessage('No se encontraron configuraciones. Por favor, crea una configuración primero.');\n            return;\n        }\n\n        if (configurations.length === 1) {\n            await provider.runSummary(configurations[0].name);\n            return;\n        }\n\n        const selected = await vscode.window.showQuickPick(\n            configurations.map(c => c.name),\n            { placeHolder: 'Selecciona una configuración para generar el resumen' }\n        );\n\n        if (selected) {\n            await provider.runSummary(selected);\n        }\n    });\n\n    context.subscriptions.push(disposable);\n}\n\nexport function deactivate() {}","module.exports = require(\"vscode\");","module.exports = require(\"fs\");","module.exports = require(\"path\");","module.exports = require(\"util\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(265);\n"],"names":["stringify","compile","expand","parse","braces","input","options","output","Array","isArray","pattern","result","create","push","concat","nodupes","Set","noempty","filter","Boolean","length","module","exports","fill","utils","ast","walk","node","parent","invalidBlock","isInvalidBrace","invalidNode","invalid","escapeInvalid","prefix","isOpen","value","isClose","console","log","type","prev","nodes","ranges","args","reduce","range","wrap","toRegex","strictZeros","child","MAX_LENGTH","CHAR_0","CHAR_9","CHAR_UPPERCASE_A","CHAR_LOWERCASE_A","CHAR_UPPERCASE_Z","CHAR_LOWERCASE_Z","CHAR_LEFT_PARENTHESES","CHAR_RIGHT_PARENTHESES","CHAR_ASTERISK","CHAR_AMPERSAND","CHAR_AT","CHAR_BACKSLASH","CHAR_BACKTICK","CHAR_CARRIAGE_RETURN","CHAR_CIRCUMFLEX_ACCENT","CHAR_COLON","CHAR_COMMA","CHAR_DOLLAR","CHAR_DOT","CHAR_DOUBLE_QUOTE","CHAR_EQUAL","CHAR_EXCLAMATION_MARK","CHAR_FORM_FEED","CHAR_FORWARD_SLASH","CHAR_HASH","CHAR_HYPHEN_MINUS","CHAR_LEFT_ANGLE_BRACKET","CHAR_LEFT_CURLY_BRACE","CHAR_LEFT_SQUARE_BRACKET","CHAR_LINE_FEED","CHAR_NO_BREAK_SPACE","CHAR_PERCENT","CHAR_PLUS","CHAR_QUESTION_MARK","CHAR_RIGHT_ANGLE_BRACKET","CHAR_RIGHT_CURLY_BRACE","CHAR_RIGHT_SQUARE_BRACKET","CHAR_SEMICOLON","CHAR_SINGLE_QUOTE","CHAR_SPACE","CHAR_TAB","CHAR_UNDERSCORE","CHAR_VERTICAL_LINE","CHAR_ZERO_WIDTH_NOBREAK_SPACE","append","queue","stash","enclose","flatten","map","ele","item","rangeLimit","undefined","p","q","dollar","pop","exceedsLimit","step","RangeError","encloseBrace","block","i","TypeError","opts","max","maxLength","Math","min","SyntaxError","stack","brackets","index","depth","advance","open","shift","commas","siblings","before","close","slice","next","keepQuotes","keepEscaping","forEach","indexOf","splice","isOpenOrClose","isInteger","num","Number","trim","find","limit","escapeNode","n","escaped","acc","flat","arr","util","toRegexRange","isObject","val","isValidValue","isNumber","zeros","pad","toNumber","dash","padStart","String","toMaxLen","negative","toRange","a","b","isNumbers","start","fromCharCode","end","capture","join","rangeError","inspect","invalidRange","strictRanges","transform","descending","startString","endString","stepString","abs","padded","maxLen","format","parts","negatives","positives","sort","v","toSequence","fillNumbers","charCodeAt","fillLetters","invalidStep","isFinite","picomatch","isEmptyString","micromatch","list","patterns","omit","keep","items","onResult","state","add","isMatch","negated","negatedExtglob","matched","delete","matches","has","failglob","Error","nonull","nullglob","unescape","replace","match","matcher","any","str","not","contains","some","includes","startsWith","matchKeys","obj","keys","Object","res","key","every","all","glob","posix","isWindows","makeRe","exec","toPosixSlashes","scan","nobrace","test","braceExpand","path","WIN_SLASH","WIN_NO_SLASH","DOT_LITERAL","SLASH_LITERAL","QMARK","END_ANCHOR","START_ANCHOR","DOTS_SLASH","POSIX_CHARS","PLUS_LITERAL","QMARK_LITERAL","ONE_CHAR","NO_DOT","NO_DOTS","NO_DOT_SLASH","NO_DOTS_SLASH","QMARK_NO_DOT","STAR","WINDOWS_CHARS","POSIX_REGEX_SOURCE","alnum","alpha","ascii","blank","cntrl","digit","graph","lower","print","punct","space","upper","word","xdigit","REGEX_BACKSLASH","REGEX_NON_SPECIAL_CHARS","REGEX_SPECIAL_CHARS","REGEX_SPECIAL_CHARS_BACKREF","REGEX_SPECIAL_CHARS_GLOBAL","REGEX_REMOVE_BACKSLASH","REPLACEMENTS","CHAR_BACKWARD_SLASH","CHAR_GRAVE_ACCENT","SEP","sep","extglobChars","chars","globChars","win32","constants","expandRange","RegExp","ex","escapeRegex","syntaxError","char","len","bos","prepend","tokens","PLATFORM_CHARS","EXTGLOB_CHARS","globstar","dot","nodot","qmarkNoDot","star","bash","noext","noextglob","consumed","backtrack","parens","quotes","removePrefix","extglobs","eos","peek","remaining","consume","token","negate","count","increment","decrement","tok","isBrace","isExtglob","extglob","inner","extglobOpen","conditions","extglobClose","rest","extglobStar","expression","fastpaths","backslashes","m","esc","first","repeat","wrapOutput","slashes","idx","lastIndexOf","pre","strictBrackets","nobracket","prevValue","literalBrackets","hasRegexChars","outputIndex","tokensIndex","brace","dots","unshift","comma","out","toks","t","supportsLookbehinds","nonegate","regex","noglobstar","prior","isStart","afterStar","after","strictSlashes","escapeLast","suffix","slashDot","source","returnState","fns","arrayMatcher","isState","compileRe","isIgnored","ignore","ignoreOpts","onMatch","returnObject","onIgnore","matchBase","basename","returnOutput","parsed","flags","nocase","err","debug","isPathSeparator","code","isPrefix","isGlobstar","Infinity","scanToEnd","lastIndex","isBracket","isGlob","braceEscaped","finished","noparen","base","removeBackslashes","maxDepth","prevIndex","process","platform","isRegexChar","segs","version","split","windows","lastIdx","relaxZeros","cacheKey","shorthand","cache","hasOwnProperty","isPadded","hasPadding","splitToPatterns","neg","pos","onlyNegative","filterPatterns","onlyPositive","intersected","collatePatterns","rangeToPattern","stop","digits","zipped","zip","startDigit","stopDigit","nines","countNines","stops","countZeros","compare","splitToRanges","padZeros","string","toQuantifier","comparison","intersection","integer","pow","diff","relax","clearCache","_extensionUri","static","constructor","resolveWebviewView","webviewView","context","_token","webview","enableScripts","html","this","getWebviewContent","onDidReceiveMessage","async","message","command","savedConfigName","saveConfiguration","sendConfigsToWebview","postMessage","configName","error","runSummary","vscode","window","showErrorMessage","deleteConfiguration","extensions","findExtensions","directoryPath","allowedDirectories","dir","excludedDirectories","excludedFiles","file","showAllExtensions","from","isExcluded","relativePath","normalizedPath","normalizePath","processDirectory","basePath","files","fs","readdirSync","fullPath","relative","statSync","isDirectory","ext","toLowerCase","allowedDir","fullAllowedPath","existsSync","selectedConfig","workspace","getConfiguration","get","c","name","summaryContent","generateSummary","summaryPath","writeFileSync","showInformationMessage","content","readFileSync","inputPath","normalized","configurations","config","newConfig","existingIndex","findIndex","update","ConfigurationTarget","Global","provider","SummaryViewProvider","extensionUri","subscriptions","registerWebviewViewProvider","viewType","disposable","commands","registerCommand","selected","showQuickPick","placeHolder","require","__webpack_module_cache__","__webpack_exports__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","call"],"sourceRoot":""}